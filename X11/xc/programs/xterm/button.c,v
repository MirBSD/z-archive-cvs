head	1.4;
access;
symbols
	MIRBSD_10_BASE:1.3
	tg-xterm-215-based:1.2.0.2
	tg-xterm-200-based:1.1
	xterm-215:1.1.109.1
	lynx:1.1.109
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.4
date	2017.01.05.14.24.04;	author tg;	state Exp;
branches;
next	1.3;
commitid	100586E57085BB3C8FE;

1.3
date	2006.07.02.00.54.42;	author tg;	state Exp;
branches;
next	1.2;
commitid	10044A719405F9E103E;

1.2
date	2006.07.02.00.02.42;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A70D294F0BB63C;

1.1
date	2005.03.18.10.52.29;	author tg;	state Exp;
branches
	1.1.103.1
	1.1.109.1;
next	;

1.1.103.1
date	2005.03.18.10.52.29;	author tg;	state Exp;
branches;
next	;

1.1.109.1
date	2006.07.01.23.27.01;	author tg;	state Exp;
branches;
next	;
commitid	10044A704BD2A6243A3;


desc
@@


1.4
log
@quick hack to make xterm transmit as many chars to the pty at one time as possible
fixes mcabber not reading UTF-8 correctly
@
text
@/* $XTermId: button.c,v 1.178 2005/02/04 21:40:20 tom Exp $ */

/* $Xorg: button.c,v 1.3 2000/08/17 19:55:08 cpqbld Exp $ */
/*
 * Copyright 1999-2004,2005 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 *
 *
 * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital Equipment
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 *
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */
/* $XFree86: xc/programs/xterm/button.c,v 3.78 2005/02/06 21:42:37 dickey Exp $ */

/*
button.c	Handles button events in the terminal emulator.
		does cut/paste operations, change modes via menu,
		passes button events through to some applications.
				J. Gettys.
*/

#include <xterm.h>

#include <stdio.h>

#include <X11/Xatom.h>
#include <X11/Xmu/Atoms.h>
#include <X11/Xmu/StdSel.h>

#include <xutf8.h>

#include <data.h>
#include <error.h>
#include <menu.h>
#include <xcharmouse.h>
#include <charclass.h>

#if OPT_WIDE_CHARS
#include <wcwidth.h>
#else
#define CharacterClass(value) \
	charClass[value & ((sizeof(charClass)/sizeof(charClass[0]))-1)]
#endif

#define XTERM_CELL(row,col) getXtermCell(screen, row + screen->topline, col)
#define XTERM_CELL_C1(row,col) getXtermCellComb1(screen, row + screen->topline, col)
#define XTERM_CELL_C2(row,col) getXtermCellComb2(screen, row + screen->topline, col)

      /*
       * We reserve shift modifier for cut/paste operations.  In principle we
       * can pass through control and meta modifiers, but in practice, the
       * popup menu uses control, and the window manager is likely to use meta,
       * so those events are not delivered to SendMousePosition.
       */
#define OurModifiers (ShiftMask | ControlMask | Mod1Mask)
#define AllModifiers (ShiftMask | LockMask | ControlMask | Mod1Mask | \
		      Mod2Mask | Mod3Mask | Mod4Mask | Mod5Mask)

#define KeyModifiers (event->xbutton.state & OurModifiers)

#define KeyState(x) (((x) & (ShiftMask|ControlMask)) + (((x) & Mod1Mask) ? 2 : 0))
    /* adds together the bits:
       shift key -> 1
       meta key  -> 2
       control key -> 4 */

#define	Coordinate(r,c)		((r) * (term->screen.max_col+1) + (c))

#if OPT_DEC_LOCATOR
static ANSI reply;
#endif

/* Selection/extension variables */

/* Raw char position where the selection started */
static int rawRow, rawCol;

/* Selected area before CHAR, WORD, LINE selectUnit processing */
static int startRRow, startRCol, endRRow, endRCol = 0;

/* Selected area after CHAR, WORD, LINE selectUnit processing */
static int startSRow, startSCol, endSRow, endSCol = 0;

/* Valid rows for selection clipping */
static int firstValidRow, lastValidRow;

/* Start, end of extension */
static int startERow, startECol, endERow, endECol;

/* Saved values of raw selection for extend to restore to */
static int saveStartRRow, saveStartRCol, saveEndRRow, saveEndRCol;

/* Saved value of WORD selection for LINE processing to restore to */
static int saveStartWRow, saveStartWCol;

/* Multi-click handling */
static int numberOfClicks = 0;
static Time lastButtonUpTime = 0;

#if OPT_READLINE
static Time lastButtonDownTime = 0;
static int ExtendingSelection = 0;
static Time lastButton3UpTime = 0;
static Time lastButton3DoubleDownTime = 0;
static int lastButton3row, lastButton3col;	/* At the release time */
#endif /* OPT_READLINE */

typedef int SelectUnit;

#define SELECTCHAR 0
#define SELECTWORD 1
#define SELECTLINE 2
#define NSELECTUNITS 3
static SelectUnit selectUnit;

/* Send emacs escape code when done selecting or extending? */
static int replyToEmacs;

static Char *SaveText(TScreen * screen, int row, int scol, int ecol, Char *
		      lp, int *eol);
static int Length(TScreen * screen, int row, int scol, int ecol);
static void ComputeSelect(int startRow, int startCol, int endRow, int
			  endCol, Bool extend);
static void EditorButton(XButtonEvent * event);
static void EndExtend(Widget w, XEvent * event, String * params, Cardinal
		      num_params, Bool use_cursor_loc);
static void ExtendExtend(int row, int col);
static void PointToRowCol(int y, int x, int *r, int *c);
static void ReHiliteText(int frow, int fcol, int trow, int tcol);
static void SaltTextAway(int crow, int ccol, int row, int col, String *
			 params, Cardinal num_params);
static void SelectSet(Widget w, XEvent * event, String * params, Cardinal num_params);
static void SelectionReceived PROTO_XT_SEL_CB_ARGS;
static void StartSelect(int startrow, int startcol);
static void TrackDown(XButtonEvent * event);
static void _OwnSelection(XtermWidget termw, String * selections, Cardinal count);
static void do_select_end(Widget w, XEvent * event, String * params,
			  Cardinal *num_params, Bool use_cursor_loc);

Bool
SendMousePosition(Widget w, XEvent * event)
{
    TScreen *screen;

    if (!IsXtermWidget(w))
	return False;

    screen = &((XtermWidget) w)->screen;

    /* If send_mouse_pos mode isn't on, we shouldn't be here */
    if (screen->send_mouse_pos == MOUSE_OFF)
	return False;

#if OPT_DEC_LOCATOR
    if (screen->send_mouse_pos == DEC_LOCATOR) {
	return (SendLocatorPosition(w, event));
    }
#endif /* OPT_DEC_LOCATOR */

    /* Make sure the event is an appropriate type */
    if ((screen->send_mouse_pos != BTN_EVENT_MOUSE)
	&& (screen->send_mouse_pos != ANY_EVENT_MOUSE)
	&& event->type != ButtonPress
	&& event->type != ButtonRelease)
	return False;

    switch (screen->send_mouse_pos) {
    case X10_MOUSE:		/* X10 compatibility sequences */

	if (KeyModifiers == 0) {
	    if (event->type == ButtonPress)
		EditorButton((XButtonEvent *) event);
	    return True;
	}
	return False;

    case VT200_HIGHLIGHT_MOUSE:	/* DEC vt200 hilite tracking */
	if (event->type == ButtonPress &&
	    KeyModifiers == 0 &&
	    event->xbutton.button == Button1) {
	    TrackDown((XButtonEvent *) event);
	    return True;
	}
	if (KeyModifiers == 0 || KeyModifiers == ControlMask) {
	    EditorButton((XButtonEvent *) event);
	    return True;
	}
	return False;

    case VT200_MOUSE:		/* DEC vt200 compatible */

	/* xterm extension for motion reporting. June 1998 */
	/* EditorButton() will distinguish between the modes */
    case BTN_EVENT_MOUSE:
    case ANY_EVENT_MOUSE:
	if (KeyModifiers == 0 || KeyModifiers == ControlMask) {
	    EditorButton((XButtonEvent *) event);
	    return True;
	}
	return False;

    default:
	return False;
    }
}

#if OPT_DEC_LOCATOR

#define	LocatorCoords( row, col, x, y, oor )			\
    if( screen->locator_pixels ) {				\
	(oor)=False; (row) = (y)+1; (col) = (x)+1;		\
	/* Limit to screen dimensions */			\
	if ((row) < 1) (row) = 1,(oor)=True;			\
	else if ((row) > screen->border*2+Height(screen))	\
	    (row) = screen->border*2+Height(screen),(oor)=True;	\
	if ((col) < 1) (col) = 1,(oor)=True;			\
	else if ((col) > OriginX(screen)*2+Width(screen))	\
	    (col) = OriginX(screen)*2+Width(screen),(oor)=True;	\
    } else {							\
	(oor)=False;						\
	/* Compute character position of mouse pointer */	\
	(row) = ((y) - screen->border) / FontHeight(screen);	\
	(col) = ((x) - OriginX(screen)) / FontWidth(screen);	\
	/* Limit to screen dimensions */			\
	if ((row) < 0) (row) = 0,(oor)=True;			\
	else if ((row) > screen->max_row)			\
	    (row) = screen->max_row,(oor)=True;			\
	if ((col) < 0) (col) = 0,(oor)=True;			\
	else if ((col) > screen->max_col)			\
	    (col) = screen->max_col,(oor)=True;			\
	(row)++; (col)++;					\
    }

Bool
SendLocatorPosition(Widget w, XEvent * event)
{
    TScreen *screen = &((XtermWidget) w)->screen;
    int row, col;
    Bool oor;
    int button;
    int state;

    /* Make sure the event is an appropriate type */
    if ((event->type != ButtonPress &&
	 event->type != ButtonRelease &&
	 !screen->loc_filter) ||
	(KeyModifiers != 0 && KeyModifiers != ControlMask))
	return (False);

    if ((event->type == ButtonPress &&
	 !(screen->locator_events & LOC_BTNS_DN)) ||
	(event->type == ButtonRelease &&
	 !(screen->locator_events & LOC_BTNS_UP)))
	return (True);

    if (event->type == MotionNotify) {
	CheckLocatorPosition(w, event);
	return (True);
    }

    /* get button # */
    button = event->xbutton.button - 1;

    LocatorCoords(row, col, event->xbutton.x, event->xbutton.y, oor);

    /*
     * DECterm mouse:
     *
     * ESCAPE '[' event ; mask ; row ; column '&' 'w'
     */
    reply.a_type = CSI;

    if (oor) {
	reply.a_nparam = 1;
	reply.a_param[0] = 0;	/* Event - 0 = locator unavailable */
	reply.a_inters = '&';
	reply.a_final = 'w';
	unparseseq(&reply, screen->respond);
	v_flushonly(screen->respond);

	if (screen->locator_reset) {
	    MotionOff(screen, term);
	    screen->send_mouse_pos = MOUSE_OFF;
	}
	return (True);
    }

    /*
     * event:
     *        1       no buttons
     *        2       left button down
     *        3       left button up
     *        4       middle button down
     *        5       middle button up
     *        6       right button down
     *        7       right button up
     *        8       M4 down
     *        9       M4 up
     */
    reply.a_nparam = 4;
    switch (event->type) {
    case ButtonPress:
	reply.a_param[0] = 2 + (button << 1);
	break;
    case ButtonRelease:
	reply.a_param[0] = 3 + (button << 1);
	break;
    default:
	return (True);
    }
    /*
     * mask:
     * bit 7   bit 6   bit 5   bit 4   bit 3   bit 2       bit 1         bit 0
     *                                 M4 down left down   middle down   right down
     *
     * Notice that Button1 (left) and Button3 (right) are swapped in the mask.
     * Also, mask should be the state after the button press/release,
     * X provides the state not including the button press/release.
     */
    state = (event->xbutton.state
	     & (Button1Mask | Button2Mask | Button3Mask | Button4Mask)) >> 8;
    state ^= 1 << button;	/* update mask to "after" state */
    state = (state & ~(4 | 1)) | ((state & 1) ? 4 : 0) | ((state & 4) ? 1 : 0);		/* swap Button1 & Button3 */

    reply.a_param[1] = state;
    reply.a_param[2] = row;
    reply.a_param[3] = col;
    reply.a_inters = '&';
    reply.a_final = 'w';

    unparseseq(&reply, screen->respond);
    v_flushonly(screen->respond);

    if (screen->locator_reset) {
	MotionOff(screen, term);
	screen->send_mouse_pos = MOUSE_OFF;
    }

    /*
     * DECterm turns the Locator off if a button is pressed while a filter rectangle
     * is active. This might be a bug, but I don't know, so I'll emulate it anyways.
     */
    if (screen->loc_filter) {
	screen->send_mouse_pos = MOUSE_OFF;
	screen->loc_filter = False;
	screen->locator_events = 0;
	MotionOff(screen, term);
    }

    return (True);
}

/*
 * mask:
 * bit 7   bit 6   bit 5   bit 4   bit 3   bit 2       bit 1         bit 0
 *                                 M4 down left down   middle down   right down
 *
 * Button1 (left) and Button3 (right) are swapped in the mask relative to X.
 */
#define	ButtonState(state, mask)	\
{ (state) = ((mask) & (Button1Mask | Button2Mask | Button3Mask | Button4Mask)) >> 8;	\
  /* swap Button1 & Button3 */								\
  (state) = ((state) & ~(4|1)) | (((state)&1)?4:0) | (((state)&4)?1:0);			\
}

void
GetLocatorPosition(XtermWidget w)
{
    TScreen *screen = &w->screen;
    Window root, child;
    int rx, ry, x, y;
    unsigned int mask;
    int row = 0, col = 0;
    Bool oor = False;
    Bool ret = False;
    int state;

    /*
     * DECterm turns the Locator off if the position is requested while a filter rectangle
     * is active.  This might be a bug, but I don't know, so I'll emulate it anyways.
     */
    if (screen->loc_filter) {
	screen->send_mouse_pos = MOUSE_OFF;
	screen->loc_filter = False;
	screen->locator_events = 0;
	MotionOff(screen, term);
    }

    reply.a_type = CSI;

    if (screen->send_mouse_pos == DEC_LOCATOR) {
	ret = XQueryPointer(screen->display, VWindow(screen), &root,
			    &child, &rx, &ry, &x, &y, &mask);
	if (ret) {
	    LocatorCoords(row, col, x, y, oor);
	}
    }
    if (ret == False || oor) {
	reply.a_nparam = 1;
	reply.a_param[0] = 0;	/* Event - 0 = locator unavailable */
	reply.a_inters = '&';
	reply.a_final = 'w';
	unparseseq(&reply, screen->respond);
	v_flushonly(screen->respond);

	if (screen->locator_reset) {
	    MotionOff(screen, term);
	    screen->send_mouse_pos = MOUSE_OFF;
	}
	return;
    }

    ButtonState(state, mask);

    reply.a_nparam = 4;
    reply.a_param[0] = 1;	/* Event - 1 = response to locator request */
    reply.a_param[1] = state;
    reply.a_param[2] = row;
    reply.a_param[3] = col;
    reply.a_inters = '&';
    reply.a_final = 'w';
    unparseseq(&reply, screen->respond);
    v_flushonly(screen->respond);

    if (screen->locator_reset) {
	MotionOff(screen, term);
	screen->send_mouse_pos = MOUSE_OFF;
    }
}

void
InitLocatorFilter(XtermWidget w)
{
    TScreen *screen = &w->screen;
    Window root, child;
    int rx, ry, x, y;
    unsigned int mask;
    int row = 0, col = 0;
    Bool oor = 0;
    Bool ret;
    int state;

    ret = XQueryPointer(screen->display, VWindow(screen),
			&root, &child, &rx, &ry, &x, &y, &mask);
    if (ret) {
	LocatorCoords(row, col, x, y, oor);
    }
    if (ret == False || oor) {
	/* Locator is unavailable */

	if (screen->loc_filter_top != LOC_FILTER_POS ||
	    screen->loc_filter_left != LOC_FILTER_POS ||
	    screen->loc_filter_bottom != LOC_FILTER_POS ||
	    screen->loc_filter_right != LOC_FILTER_POS) {
	    /*
	     * If any explicit coordinates were received,
	     * report immediately with no coordinates.
	     */
	    reply.a_type = CSI;
	    reply.a_nparam = 1;
	    reply.a_param[0] = 0;	/* Event - 0 = locator unavailable */
	    reply.a_inters = '&';
	    reply.a_final = 'w';
	    unparseseq(&reply, screen->respond);
	    v_flushonly(screen->respond);

	    if (screen->locator_reset) {
		MotionOff(screen, term);
		screen->send_mouse_pos = MOUSE_OFF;
	    }
	} else {
	    /*
	     * No explicit coordinates were received, and the pointer is
	     * unavailable.  Report when the pointer re-enters the window.
	     */
	    screen->loc_filter = True;
	    MotionOn(screen, term);
	}
	return;
    }

    /*
     * Adjust rectangle coordinates:
     *  1. Replace "LOC_FILTER_POS" with current coordinates
     *  2. Limit coordinates to screen size
     *  3. make sure top and left are less than bottom and right, resp.
     */
    if (screen->locator_pixels) {
	rx = OriginX(screen) * 2 + Width(screen);
	ry = screen->border * 2 + Height(screen);
    } else {
	rx = screen->max_col;
	ry = screen->max_row;
    }

#define	Adjust( coord, def, max )				\
	if( (coord) == LOC_FILTER_POS )	(coord) = (def);	\
	else if ((coord) < 1)		(coord) = 1;		\
	else if ((coord) > (max))	(coord) = (max)

    Adjust(screen->loc_filter_top, row, ry);
    Adjust(screen->loc_filter_left, col, rx);
    Adjust(screen->loc_filter_bottom, row, ry);
    Adjust(screen->loc_filter_right, col, rx);

    if (screen->loc_filter_top > screen->loc_filter_bottom) {
	ry = screen->loc_filter_top;
	screen->loc_filter_top = screen->loc_filter_bottom;
	screen->loc_filter_bottom = ry;
    }

    if (screen->loc_filter_left > screen->loc_filter_right) {
	rx = screen->loc_filter_left;
	screen->loc_filter_left = screen->loc_filter_right;
	screen->loc_filter_right = rx;
    }

    if ((col < screen->loc_filter_left) ||
	(col > screen->loc_filter_right) ||
	(row < screen->loc_filter_top) ||
	(row > screen->loc_filter_bottom)) {
	/* Pointer is already outside the rectangle - report immediately */
	ButtonState(state, mask);

	reply.a_type = CSI;
	reply.a_nparam = 4;
	reply.a_param[0] = 10;	/* Event - 10 = locator outside filter */
	reply.a_param[1] = state;
	reply.a_param[2] = row;
	reply.a_param[3] = col;
	reply.a_inters = '&';
	reply.a_final = 'w';
	unparseseq(&reply, screen->respond);
	v_flushonly(screen->respond);

	if (screen->locator_reset) {
	    MotionOff(screen, term);
	    screen->send_mouse_pos = MOUSE_OFF;
	}
	return;
    }

    /*
     * Rectangle is set up.  Allow pointer tracking
     * to detect if the mouse leaves the rectangle.
     */
    screen->loc_filter = True;
    MotionOn(screen, term);
}

void
CheckLocatorPosition(Widget w, XEvent * event)
{
    TScreen *screen = &((XtermWidget) w)->screen;
    int row, col;
    Bool oor;
    int state;

    LocatorCoords(row, col, event->xbutton.x, event->xbutton.y, oor);

    /*
     * Send report if the pointer left the filter rectangle, if
     * the pointer left the window, or if the filter rectangle
     * had no coordinates and the pointer re-entered the window.
     */
    if (oor || (screen->loc_filter_top == LOC_FILTER_POS) ||
	(col < screen->loc_filter_left) ||
	(col > screen->loc_filter_right) ||
	(row < screen->loc_filter_top) ||
	(row > screen->loc_filter_bottom)) {
	/* Filter triggered - disable it */
	screen->loc_filter = False;
	MotionOff(screen, term);

	reply.a_type = CSI;
	if (oor) {
	    reply.a_nparam = 1;
	    reply.a_param[0] = 0;	/* Event - 0 = locator unavailable */
	} else {
	    ButtonState(state, event->xbutton.state);

	    reply.a_nparam = 4;
	    reply.a_param[0] = 10;	/* Event - 10 = locator outside filter */
	    reply.a_param[1] = state;
	    reply.a_param[2] = row;
	    reply.a_param[3] = col;
	}

	reply.a_inters = '&';
	reply.a_final = 'w';
	unparseseq(&reply, screen->respond);
	v_flushonly(screen->respond);

	if (screen->locator_reset) {
	    MotionOff(screen, term);
	    screen->send_mouse_pos = MOUSE_OFF;
	}
    }
}
#endif /* OPT_DEC_LOCATOR */

#if OPT_READLINE
static int
isClick1_clean(XEvent * event)
{
    TScreen *screen = &term->screen;
    int delta;

    if (!(event->type == ButtonPress || event->type == ButtonRelease)
    /* Disable on Shift-Click-1, including the application-mouse modes */
	|| (KeyModifiers & ShiftMask)
	|| (screen->send_mouse_pos != MOUSE_OFF)	/* Kinda duplicate... */
	||ExtendingSelection)	/* Was moved */
	return 0;
    if (event->type != ButtonRelease)
	return 0;
    if (lastButtonDownTime == (Time) 0)		/* first time or once in a blue moon */
	delta = term->screen.multiClickTime + 1;
    else if (event->xbutton.time > lastButtonDownTime)	/* most of the time */
	delta = event->xbutton.time - lastButtonDownTime;
    else			/* time has rolled over since lastButtonUpTime */
	delta = (((Time) ~ 0) - lastButtonDownTime) + event->xbutton.time;
    return delta <= term->screen.multiClickTime;
}

static int
isDoubleClick3(XEvent * event)
{
    int delta;

    if (event->type != ButtonRelease
	|| (KeyModifiers & ShiftMask)
	|| event->xbutton.button != Button3) {
	lastButton3UpTime = 0;	/* Disable the cached info */
	return 0;
    }
    /* Process Btn3Release. */
    if (lastButton3DoubleDownTime == (Time) 0)	/* No previous click
						   or once in a blue moon */
	delta = term->screen.multiClickTime + 1;
    else if (event->xbutton.time > lastButton3DoubleDownTime)	/* most of the time */
	delta = event->xbutton.time - lastButton3DoubleDownTime;
    else			/* time has rolled over since lastButton3DoubleDownTime */
	delta = (((Time) ~ 0) - lastButton3DoubleDownTime) + event->xbutton.time;
    if (delta <= term->screen.multiClickTime) {
	/* Double click */
	int row, col;

	/* Cannot check ExtendingSelection, since mouse-3 always sets it */
	PointToRowCol(event->xbutton.y, event->xbutton.x, &row, &col);
	if (row == lastButton3row && col == lastButton3col) {
	    lastButton3DoubleDownTime = 0;	/* Disable the third click */
	    return 1;
	}
    }
    /* Not a double click, memorize for future check. */
    lastButton3UpTime = event->xbutton.time;
    PointToRowCol(event->xbutton.y, event->xbutton.x,
		  &lastButton3row, &lastButton3col);
    return 0;
}

static int
CheckSecondPress3(XEvent * event)
{
    int delta, row, col;

    if (event->type != ButtonPress
	|| (KeyModifiers & ShiftMask)
	|| event->xbutton.button != Button3) {
	lastButton3DoubleDownTime = 0;	/* Disable the cached info */
	return 0;
    }
    /* Process Btn3Press. */
    if (lastButton3UpTime == (Time) 0)	/* No previous click
					   or once in a blue moon */
	delta = term->screen.multiClickTime + 1;
    else if (event->xbutton.time > lastButton3UpTime)	/* most of the time */
	delta = event->xbutton.time - lastButton3UpTime;
    else			/* time has rolled over since lastButton3UpTime */
	delta = (((Time) ~ 0) - lastButton3UpTime) + event->xbutton.time;
    if (delta <= term->screen.multiClickTime) {
	PointToRowCol(event->xbutton.y, event->xbutton.x, &row, &col);
	if (row == lastButton3row && col == lastButton3col) {
	    /* A candidate for a double-click */
	    lastButton3DoubleDownTime = event->xbutton.time;
	    PointToRowCol(event->xbutton.y, event->xbutton.x,
			  &lastButton3row, &lastButton3col);
	    return 1;
	}
	lastButton3UpTime = 0;	/* Disable the info about the previous click */
    }
    /* Either too long, or moved, disable. */
    lastButton3DoubleDownTime = 0;
    return 0;
}

static int
rowOnCurrentLine(int line, int *deltap)		/* must be XButtonEvent */
{
    TScreen *screen = &term->screen;
    int l1, l2;

    *deltap = 0;
    if (line == screen->cur_row)
	return 1;

    if (line < screen->cur_row)
	l1 = line, l2 = screen->cur_row;
    else
	l2 = line, l1 = screen->cur_row;
    l1--;
    while (++l1 < l2)
	if (!ScrnTstWrapped(screen, l1))
	    return 0;
    /* Everything is on one "wrapped line" now */
    *deltap = line - screen->cur_row;
    return 1;
}

static int
eventRow(XEvent * event)	/* must be XButtonEvent */
{
    TScreen *screen = &term->screen;

    return (event->xbutton.y - screen->border) / FontHeight(screen);
}

static int
eventColBetween(XEvent * event)	/* must be XButtonEvent */
{
    TScreen *screen = &term->screen;

    /* Correct by half a width - we are acting on a boundary, not on a cell. */
    return ((event->xbutton.x - OriginX(screen) + (FontWidth(screen) - 1) / 2)
	    / FontWidth(screen));
}

static int
ReadLineMovePoint(int col, int ldelta)
{
    TScreen *screen = &term->screen;
    Char line[6];
    unsigned count = 0;

    col += ldelta * (screen->max_col + 1) - screen->cur_col;
    if (col == 0)
	return 0;
    if (screen->control_eight_bits) {
	line[count++] = CSI;
    } else {
	line[count++] = ESC;
	line[count++] = '[';	/* XXX maybe sometimes O is better? */
    }
    line[count++] = (col > 0 ? 'C' : 'D');
    if (col < 0)
	col = -col;
    while (col--)
	v_writeonly(screen->respond, line, 3);
    v_flushonly(screen->respond);
    return 1;
}

static int
ReadLineDelete(int r1, int c1, int r2, int c2)
{
    TScreen *screen = &term->screen;
    int del;

    del = c2 - c1 + (r2 - r1) * (screen->max_col + 1);
    if (del <= 0)		/* Just in case... */
	return 0;
    while (del--)
	v_writeonly(screen->respond, "\177", 1);	/* XXX Sometimes "\08"? */
    v_flushonly(screen->respond);
    return 1;
}
#endif /* OPT_READLINE */

/* ^XM-G<line+' '><col+' '> */
void
DiredButton(Widget w GCC_UNUSED,
	    XEvent * event,	/* must be XButtonEvent */
	    String * params GCC_UNUSED,		/* selections */
	    Cardinal *num_params GCC_UNUSED)
{
    TScreen *screen = &term->screen;
    Char Line[6];
    unsigned line, col;

    if (event->type == ButtonPress || event->type == ButtonRelease) {
	line = (event->xbutton.y - screen->border) / FontHeight(screen);
	col = (event->xbutton.x - OriginX(screen)) / FontWidth(screen);
	Line[0] = CONTROL('X');
	Line[1] = ESC;
	Line[2] = 'G';
	Line[3] = ' ' + col;
	Line[4] = ' ' + line;
	v_write(screen->respond, Line, 5);
    }
}

#if OPT_READLINE
void
ReadLineButton(Widget w GCC_UNUSED,
	       XEvent * event,	/* must be XButtonEvent */
	       String * params GCC_UNUSED,	/* selections */
	       Cardinal *num_params GCC_UNUSED)
{
    TScreen *screen = &term->screen;
    Char Line[6];
    int line, col, ldelta = 0;

    if (!(event->type == ButtonPress || event->type == ButtonRelease)
	|| (screen->send_mouse_pos != MOUSE_OFF) || ExtendingSelection)
	goto finish;
    if (event->type == ButtonRelease) {
	int delta;

	if (lastButtonDownTime == (Time) 0)	/* first time and once in a blue moon */
	    delta = screen->multiClickTime + 1;
	else if (event->xbutton.time > lastButtonDownTime)	/* most of the time */
	    delta = event->xbutton.time - lastButtonDownTime;
	else			/* time has rolled over since lastButtonUpTime */
	    delta = (((Time) ~ 0) - lastButtonDownTime) + event->xbutton.time;
	if (delta > screen->multiClickTime)
	    goto finish;	/* All this work for this... */
    }
    line = (event->xbutton.y - screen->border) / FontHeight(screen);
    if (line != screen->cur_row) {
	int l1, l2;

	if (line < screen->cur_row)
	    l1 = line, l2 = screen->cur_row;
	else
	    l2 = line, l1 = screen->cur_row;
	l1--;
	while (++l1 < l2)
	    if (!ScrnTstWrapped(screen, l1))
		goto finish;
	/* Everything is on one "wrapped line" now */
	ldelta = line - screen->cur_row;
    }
    /* Correct by half a width - we are acting on a boundary, not on a cell. */
    col = (event->xbutton.x - OriginX(screen) + (FontWidth(screen) - 1) / 2)
	/ FontWidth(screen) - screen->cur_col + ldelta * (screen->max_col + 1);
    if (col == 0)
	goto finish;
    Line[0] = ESC;
    /* XXX: sometimes it is better to send '['? */
    Line[1] = 'O';
    Line[2] = (col > 0 ? 'C' : 'D');
    if (col < 0)
	col = -col;
    while (col--)
	v_writeonly(screen->respond, Line, 3);
    v_flushonly(screen->respond);
  finish:
    if (event->type == ButtonRelease)
	do_select_end(w, event, params, num_params, False);
}
#endif /* OPT_READLINE */

/* repeats <ESC>n or <ESC>p */
void
ViButton(Widget w GCC_UNUSED,
	 XEvent * event,	/* must be XButtonEvent */
	 String * params GCC_UNUSED,	/* selections */
	 Cardinal *num_params GCC_UNUSED)
{
    TScreen *screen = &term->screen;
    int pty = screen->respond;
    Char Line[6];
    int line;

    if (event->type == ButtonPress || event->type == ButtonRelease) {

	line = screen->cur_row -
	    ((event->xbutton.y - screen->border) / FontHeight(screen));
	if (line != 0) {
	    Line[0] = ESC;	/* force an exit from insert-mode */
	    v_writeonly(pty, Line, 1);

	    if (line < 0) {
		line = -line;
		Line[0] = CONTROL('n');
	    } else {
		Line[0] = CONTROL('p');
	    }
	    while (--line >= 0)
		v_writeonly(pty, Line, 1);
	    v_flushonly(pty);
	}
    }
}

/*
 * This function handles button-motion events
 */
/*ARGSUSED*/
void
HandleSelectExtend(Widget w,
		   XEvent * event,	/* must be XMotionEvent */
		   String * params GCC_UNUSED,
		   Cardinal *num_params GCC_UNUSED)
{
    TScreen *screen;
    int row, col;

    if (!IsXtermWidget(w))
	return;

    screen = &((XtermWidget) w)->screen;
    screen->selection_time = event->xmotion.time;
    switch (eventMode) {
	/* If not in one of the DEC mouse-reporting modes */
    case LEFTEXTENSION:
    case RIGHTEXTENSION:
	PointToRowCol(event->xmotion.y, event->xmotion.x,
		      &row, &col);
	ExtendExtend(row, col);
	break;

	/* If in motion reporting mode, send mouse position to
	   character process as a key sequence \E[M... */
    case NORMAL:
	/* will get here if send_mouse_pos != MOUSE_OFF */
	if (screen->send_mouse_pos == BTN_EVENT_MOUSE
	    || screen->send_mouse_pos == ANY_EVENT_MOUSE) {
	    (void) SendMousePosition(w, event);
	}
	break;
    }
}

static void
do_select_end(Widget w,
	      XEvent * event,	/* must be XButtonEvent */
	      String * params,	/* selections */
	      Cardinal *num_params,
	      Bool use_cursor_loc)
{
#if OPT_READLINE
    int ldelta1, ldelta2;
    TScreen *screen = &term->screen;
#endif

    if (!IsXtermWidget(w)) {
	return;
    }

    ((XtermWidget) w)->screen.selection_time = event->xbutton.time;
    switch (eventMode) {
    case NORMAL:
	(void) SendMousePosition(w, event);
	break;
    case LEFTEXTENSION:
    case RIGHTEXTENSION:
	EndExtend(w, event, params, *num_params, use_cursor_loc);
#if OPT_READLINE
	if (isClick1_clean(event)
	    && SCREEN_FLAG(screen, click1_moves)
	    && rowOnCurrentLine(eventRow(event), &ldelta1)) {
	    ReadLineMovePoint(eventColBetween(event), ldelta1);
	}
	if (isDoubleClick3(event)
	    && SCREEN_FLAG(screen, dclick3_deletes)
	    && rowOnCurrentLine(startSRow, &ldelta1)
	    && rowOnCurrentLine(endSRow, &ldelta2)) {
	    ReadLineMovePoint(endSCol, ldelta2);
	    ReadLineDelete(startSRow, startSCol, endSRow, endSCol);
	}
#endif /* OPT_READLINE */
	break;
    }
}

void
HandleSelectEnd(Widget w,
		XEvent * event,	/* must be XButtonEvent */
		String * params,	/* selections */
		Cardinal *num_params)
{
    do_select_end(w, event, params, num_params, False);
}

void
HandleKeyboardSelectEnd(Widget w,
			XEvent * event,		/* must be XButtonEvent */
			String * params,	/* selections */
			Cardinal *num_params)
{
    do_select_end(w, event, params, num_params, True);
}

struct _SelectionList {
    String *params;
    Cardinal count;
    Atom *targets;
    Time time;
};

/* convert a UTF-8 string to Latin-1, replacing non Latin-1 characters
 * by `#'. */

#if OPT_WIDE_CHARS
static Char *
UTF8toLatin1(Char * s, unsigned len, unsigned long *result)
{
    static Char *buffer;
    static size_t used;

    Char *p = s;
    Char *q;

    if (used == 0) {
	buffer = (Char *) XtMalloc(used = len);
    } else if (len > used) {
	buffer = (Char *) XtRealloc((char *) buffer, used = len);
    }
    q = buffer;

    /* We're assuming that the xterm widget never contains Unicode
       control characters. */

    while (p < s + len) {
	if ((*p & 0x80) == 0) {
	    *q++ = *p++;
	} else if ((*p & 0x7C) == 0x40 && p < s + len - 1) {
	    *q++ = ((*p & 0x03) << 6) | (p[1] & 0x3F);
	    p += 2;
	} else if ((*p & 0x60) == 0x40) {
	    *q++ = '#';
	    p += 2;
	} else if ((*p & 0x50) == 0x40) {
	    *q++ = '#';
	    p += 3;
	} else {		/* this cannot happen */
	    *q++ = '#';
	    p++;
	}
    }
    *result = q - buffer;
    return buffer;
}
#endif /* OPT_WIDE_CHARS */

static Atom *
_SelectionTargets(Widget w)
{
    static Atom *eightBitSelectionTargets = NULL;
    TScreen *screen;
    int n;

    if (!IsXtermWidget(w))
	return NULL;

    screen = &((XtermWidget) w)->screen;

#if OPT_WIDE_CHARS
    if (screen->wide_chars) {
	static Atom *utf8SelectionTargets = NULL;

	if (utf8SelectionTargets == NULL) {
	    utf8SelectionTargets = (Atom *) XtMalloc(5 * sizeof(Atom));
	    if (utf8SelectionTargets == NULL) {
		TRACE(("Couldn't allocate utf8SelectionTargets\n"));
		return NULL;
	    }
	    n = 0;
	    utf8SelectionTargets[n++] = XA_UTF8_STRING(XtDisplay(w));
#ifdef X_HAVE_UTF8_STRING
	    if (screen->i18nSelections) {
		utf8SelectionTargets[n++] = XA_TEXT(XtDisplay(w));
		utf8SelectionTargets[n++] = XA_COMPOUND_TEXT(XtDisplay(w));
	    }
#endif
	    utf8SelectionTargets[n++] = XA_STRING;
	    utf8SelectionTargets[n] = None;
	}
	return utf8SelectionTargets;
    }
#endif

    /* not screen->wide_chars */
    if (eightBitSelectionTargets == NULL) {
	eightBitSelectionTargets = (Atom *) XtMalloc(5 * sizeof(Atom));
	if (eightBitSelectionTargets == NULL) {
	    TRACE(("Couldn't allocate eightBitSelectionTargets\n"));
	    return NULL;
	}
	n = 0;
#ifdef X_HAVE_UTF8_STRING
	eightBitSelectionTargets[n++] = XA_UTF8_STRING(XtDisplay(w));
#endif
	if (screen->i18nSelections) {
	    eightBitSelectionTargets[n++] = XA_TEXT(XtDisplay(w));
	    eightBitSelectionTargets[n++] = XA_COMPOUND_TEXT(XtDisplay(w));
	}
	eightBitSelectionTargets[n++] = XA_STRING;
	eightBitSelectionTargets[n] = None;
    }
    return eightBitSelectionTargets;
}

/*
 * Lookup the cut-buffer number, which will be in the range 0-7.
 * If it is not a cut-buffer, it is the primary selection (-1).
 */
static int
CutBuffer(unsigned code)
{
    int cutbuffer;
    switch (code) {
    case XA_CUT_BUFFER0:
	cutbuffer = 0;
	break;
    case XA_CUT_BUFFER1:
	cutbuffer = 1;
	break;
    case XA_CUT_BUFFER2:
	cutbuffer = 2;
	break;
    case XA_CUT_BUFFER3:
	cutbuffer = 3;
	break;
    case XA_CUT_BUFFER4:
	cutbuffer = 4;
	break;
    case XA_CUT_BUFFER5:
	cutbuffer = 5;
	break;
    case XA_CUT_BUFFER6:
	cutbuffer = 6;
	break;
    case XA_CUT_BUFFER7:
	cutbuffer = 7;
	break;
    default:
	cutbuffer = -1;
	break;
    }
    return cutbuffer;
}

static void
_GetSelection(Widget w,
	      Time ev_time,
	      String * params,	/* selections in precedence order */
	      Cardinal num_params,
	      Atom * targets)
{
    Atom selection;
    int cutbuffer;
    Atom target;

    if (!IsXtermWidget(w))
	return;

#if OPT_TRACE
    TRACE(("_GetSelection\n"));
    if (num_params > 0) {
	Cardinal n;
	for (n = 0; n < num_params; ++n) {
	    TRACE(("param[%d]:%s\n", n, params[n]));
	}
    }
#endif

    XmuInternStrings(XtDisplay(w), params, (Cardinal) 1, &selection);
    cutbuffer = CutBuffer(selection);
    TRACE(("Cutbuffer: %d, target: %lu\n", cutbuffer,
	   targets ? (unsigned long) targets[0] : 0));
    if (cutbuffer >= 0) {
	int inbytes;
	unsigned long nbytes;
	int fmt8 = 8;
	Atom type = XA_STRING;
	char *line;

	/* 'line' is freed in SelectionReceived */
	line = XFetchBuffer(XtDisplay(w), &inbytes, cutbuffer);
	nbytes = (unsigned long) inbytes;
	if (nbytes > 0)
	    SelectionReceived(w, NULL, &selection, &type, (XtPointer) line,
			      &nbytes, &fmt8);
	else if (num_params > 1)
	    _GetSelection(w, ev_time, params + 1, num_params - 1, NULL);
	return;
    } else {
	struct _SelectionList *list;

	if (targets == NULL || targets[0] == None) {
	    targets = _SelectionTargets(w);
	}

	if (targets != 0) {
	    target = targets[0];

	    if (targets[1] == None) {	/* last target in list */
		params++;
		num_params--;
		targets = _SelectionTargets(w);
	    } else {
		targets = &(targets[1]);
	    }

	    if (num_params) {
		/* 'list' is freed in SelectionReceived */
		list = XtNew(struct _SelectionList);
		if (list != 0) {
		    list->params = params;
		    list->count = num_params;
		    list->targets = targets;
		    list->time = ev_time;
		}
	    } else {
		list = NULL;
	    }

	    XtGetSelectionValue(w, selection,
				target,
				SelectionReceived,
				(XtPointer) list, ev_time);
	}
    }
}

#if OPT_TRACE && OPT_WIDE_CHARS
static void
GettingSelection(Display * dpy, Atom type, Char * line, unsigned long len)
{
    Char *cp;
    char *name;

    name = XGetAtomName(dpy, type);

    Trace("Getting %s (%ld)\n", name, (long int) type);
    for (cp = line; cp < line + len; cp++)
	Trace("%c\n", *cp);
}
#else
#define GettingSelection(dpy,type,line,len)	/* nothing */
#endif

#ifdef VMS
#  define tty_vwrite(pty,lag,l)		tt_write(lag,l)
#  define tty_vflush(pty)		/* nothing */
#else /* !( VMS ) */
#  define tty_vwrite(pty,lag,l)		v_writeonly(pty,lag,l)
#  define tty_vflush(pty)		v_flushonly(pty)
#endif /* defined VMS */

static void
_qWriteSelectionData(TScreen * screen, Char * lag, unsigned length)
{
#if OPT_READLINE
    if (SCREEN_FLAG(screen, paste_quotes)) {
	while (length--) {
	    tty_vwrite(screen->respond, "\026", 1);	/* Control-V */
	    tty_vwrite(screen->respond, lag++, 1);
	}
    } else
#endif
	tty_vwrite(screen->respond, lag, length);
    tty_vflush(screen->respond);
}

static void
_WriteSelectionData(TScreen * screen, Char * line, int length)
{
    /* Write data to pty a line at a time. */
    /* Doing this one line at a time may no longer be necessary
       because v_write has been re-written. */

    Char *lag, *cp, *end;

    /* in the VMS version, if tt_pasting isn't set to True then qio
       reads aren't blocked and an infinite loop is entered, where the
       pasted text shows up as new input, goes in again, shows up
       again, ad nauseum. */
#ifdef VMS
    tt_pasting = True;
#endif

    end = &line[length];
    lag = line;
    if (!SCREEN_FLAG(screen, paste_literal_nl)) {
	for (cp = line; cp != end; cp++) {
	    if (*cp == '\n') {
		*cp = '\r';
		_qWriteSelectionData(screen, lag, (unsigned) (cp - lag + 1));
		lag = cp + 1;
	    }
	}
    }
    if (lag != end) {
	_qWriteSelectionData(screen, lag, (unsigned) (end - lag));
    }
#ifdef VMS
    tt_pasting = False;
    tt_start_read();		/* reenable reads or a character may be lost */
#endif
}

#if OPT_READLINE
static void
_WriteKey(TScreen * screen, Char * in)
{
    char line[16];
    unsigned count = 0;
    unsigned length = strlen(in);

    if (screen->control_eight_bits) {
	line[count++] = CSI;
    } else {
	line[count++] = ESC;
	line[count++] = '[';
    }
    while (length--)
	line[count++] = *in++;
    line[count++] = '~';
    tty_vwrite(screen->respond, line, count);
    tty_vflush(screen->respond);
}
#endif /* OPT_READLINE */

/* SelectionReceived: stuff received selection text into pty */

/* ARGSUSED */
static void
SelectionReceived(Widget w,
		  XtPointer client_data,
		  Atom * selection GCC_UNUSED,
		  Atom * type,
		  XtPointer value,
		  unsigned long *length,
		  int *format GCC_UNUSED)
{
    char **text_list = NULL;
    int text_list_count;
    XTextProperty text_prop;
    TScreen *screen;
    Display *dpy;
#if OPT_TRACE && OPT_WIDE_CHARS
    Char *line = (Char *) value;
#endif

    if (!IsXtermWidget(w))
	return;
    screen = &((XtermWidget) w)->screen;
    dpy = XtDisplay(w);

    if (*type == 0		/*XT_CONVERT_FAIL */
	|| *length == 0
	|| value == NULL)
	goto fail;

    text_prop.value = (unsigned char *) value;
    text_prop.encoding = *type;
    text_prop.format = *format;
    text_prop.nitems = *length;

#if OPT_WIDE_CHARS
    if (screen->wide_chars) {
	if (*type == XA_UTF8_STRING(XtDisplay(w)) ||
	    *type == XA_STRING ||
	    *type == XA_COMPOUND_TEXT(XtDisplay(w))) {
	    GettingSelection(dpy, *type, line, *length);
	    if (Xutf8TextPropertyToTextList(dpy, &text_prop,
					    &text_list,
					    &text_list_count) < 0) {
		TRACE(("Conversion failed\n"));
		text_list = NULL;
	    }
	}
    } else
#endif /* OPT_WIDE_CHARS */
    {
	/* Convert the selection to locale's multibyte encoding. */

	/* There's no need to special-case UTF8_STRING.  If Xlib
	   doesn't know about it, we didn't request it.  If a broken
	   selection holder sends it anyhow, the conversion function
	   will fail. */

	if (*type == XA_UTF8_STRING(XtDisplay(w)) ||
	    *type == XA_STRING ||
	    *type == XA_COMPOUND_TEXT(XtDisplay(w))) {
	    Status rc;
	    GettingSelection(dpy, *type, line, *length);
	    if (*type == XA_STRING && screen->brokenSelections) {
		rc = XTextPropertyToStringList(&text_prop,
					       &text_list, &text_list_count);
	    } else {
		rc = XmbTextPropertyToTextList(dpy, &text_prop,
					       &text_list,
					       &text_list_count);
	    }
	    if (rc < 0) {
		TRACE(("Conversion failed\n"));
		text_list = NULL;
	    }
	}
    }

    if (text_list != NULL && text_list_count != 0) {
	int i;

#if OPT_READLINE
	if (SCREEN_FLAG(screen, paste_brackets))
	    _WriteKey(screen, "200");
#endif
	for (i = 0; i < text_list_count; i++) {
	    int len = strlen(text_list[i]);
	    _WriteSelectionData(screen, (Char *) text_list[i], len);
	}
#if OPT_READLINE
	if (SCREEN_FLAG(screen, paste_brackets))
	    _WriteKey(screen, "201");
#endif
	XFreeStringList(text_list);
    } else
	goto fail;

    XtFree((char *) client_data);
    XtFree((char *) value);

    return;

  fail:
    if (client_data != 0) {
	struct _SelectionList *list = (struct _SelectionList *) client_data;
	_GetSelection(w, list->time,
		      list->params, list->count, list->targets);
	XtFree((char *) client_data);
    }
    return;
}

void
HandleInsertSelection(Widget w,
		      XEvent * event,	/* assumed to be XButtonEvent* */
		      String * params,	/* selections in precedence order */
		      Cardinal *num_params)
{
#if OPT_READLINE
    int ldelta;
    TScreen *screen = &((XtermWidget) w)->screen;
#endif

    if (SendMousePosition(w, event))
	return;

#if OPT_READLINE
    if ((event->type == ButtonPress || event->type == ButtonRelease)
    /* Disable on Shift-mouse, including the application-mouse modes */
	&& !(KeyModifiers & ShiftMask)
	&& (screen->send_mouse_pos == MOUSE_OFF)
	&& SCREEN_FLAG(screen, paste_moves)
	&& rowOnCurrentLine(eventRow(event), &ldelta))
	ReadLineMovePoint(eventColBetween(event), ldelta);
#endif /* OPT_READLINE */

    _GetSelection(w, event->xbutton.time, params, *num_params, NULL);
}

static SelectUnit
EvalSelectUnit(Time buttonDownTime, SelectUnit defaultUnit)
{
    int delta;

    if (lastButtonUpTime == (Time) 0)	/* first time and once in a blue moon */
	delta = term->screen.multiClickTime + 1;
    else if (buttonDownTime > lastButtonUpTime)		/* most of the time */
	delta = buttonDownTime - lastButtonUpTime;
    else			/* time has rolled over since lastButtonUpTime */
	delta = (((Time) ~ 0) - lastButtonUpTime) + buttonDownTime;

    if (delta > term->screen.multiClickTime) {
	numberOfClicks = 1;
	return defaultUnit;
    } else {
	++numberOfClicks;
	return ((selectUnit + 1) % NSELECTUNITS);
    }
}

static void
do_select_start(Widget w,
		XEvent * event,	/* must be XButtonEvent* */
		int startrow,
		int startcol)
{
    if (SendMousePosition(w, event))
	return;
    selectUnit = EvalSelectUnit(event->xbutton.time, SELECTCHAR);
    replyToEmacs = False;

#if OPT_READLINE
    lastButtonDownTime = event->xbutton.time;
#endif

    StartSelect(startrow, startcol);
}

/* ARGSUSED */
void
HandleSelectStart(Widget w,
		  XEvent * event,	/* must be XButtonEvent* */
		  String * params GCC_UNUSED,
		  Cardinal *num_params GCC_UNUSED)
{
    TScreen *screen;
    int startrow, startcol;

    if (!IsXtermWidget(w))
	return;

    screen = &((XtermWidget) w)->screen;
    firstValidRow = 0;
    lastValidRow = screen->max_row;
    PointToRowCol(event->xbutton.y, event->xbutton.x, &startrow, &startcol);

#if OPT_READLINE
    ExtendingSelection = 0;
#endif

    do_select_start(w, event, startrow, startcol);
}

/* ARGSUSED */
void
HandleKeyboardSelectStart(Widget w,
			  XEvent * event,	/* must be XButtonEvent* */
			  String * params GCC_UNUSED,
			  Cardinal *num_params GCC_UNUSED)
{
    TScreen *screen;

    if (!IsXtermWidget(w))
	return;

    screen = &((XtermWidget) w)->screen;
    do_select_start(w, event, screen->cursor_row, screen->cursor_col);
}

static void
TrackDown(XButtonEvent * event)
{
    int startrow, startcol;

    selectUnit = EvalSelectUnit(event->time, SELECTCHAR);
    if (numberOfClicks > 1) {
	PointToRowCol(event->y, event->x, &startrow, &startcol);
	replyToEmacs = True;
	StartSelect(startrow, startcol);
    } else {
	waitingForTrackInfo = 1;
	EditorButton((XButtonEvent *) event);
    }
}

#define boundsCheck(x)	if (x < 0) \
			    x = 0; \
			else if (x >= screen->max_row) \
			    x = screen->max_row;

void
TrackMouse(int func, int startrow, int startcol, int firstrow, int lastrow)
{
    TScreen *screen = &term->screen;

    if (!waitingForTrackInfo) {	/* Timed out, so ignore */
	return;
    }
    waitingForTrackInfo = 0;
    if (func == 0)
	return;
    boundsCheck(startrow)
	boundsCheck(firstrow)
	boundsCheck(lastrow)
	firstValidRow = firstrow;
    lastValidRow = lastrow;
    replyToEmacs = True;
    StartSelect(startrow, startcol);
}

static void
StartSelect(int startrow, int startcol)
{
    TScreen *screen = &term->screen;

    TRACE(("StartSelect row=%d, col=%d\n", startrow, startcol));
    if (screen->cursor_state)
	HideCursor();
    if (numberOfClicks == 1) {
	/* set start of selection */
	rawRow = startrow;
	rawCol = startcol;

    }
    /* else use old values in rawRow, Col */
    saveStartRRow = startERow = rawRow;
    saveStartRCol = startECol = rawCol;
    saveEndRRow = endERow = rawRow;
    saveEndRCol = endECol = rawCol;
    if (Coordinate(startrow, startcol) < Coordinate(rawRow, rawCol)) {
	eventMode = LEFTEXTENSION;
	startERow = startrow;
	startECol = startcol;
    } else {
	eventMode = RIGHTEXTENSION;
	endERow = startrow;
	endECol = startcol;
    }
    ComputeSelect(startERow, startECol, endERow, endECol, False);
}

static void
EndExtend(Widget w,
	  XEvent * event,	/* must be XButtonEvent */
	  String * params,	/* selections */
	  Cardinal num_params,
	  Bool use_cursor_loc)
{
    int row, col;
    unsigned count;
    TScreen *screen = &term->screen;
    Char line[9];

    if (use_cursor_loc) {
	row = screen->cursor_row;
	col = screen->cursor_col;
    } else {
	PointToRowCol(event->xbutton.y, event->xbutton.x, &row, &col);
    }
    ExtendExtend(row, col);
    lastButtonUpTime = event->xbutton.time;
    if (startSRow != endSRow || startSCol != endSCol) {
	if (replyToEmacs) {
	    count = 0;
	    if (screen->control_eight_bits) {
		line[count++] = CSI;
	    } else {
		line[count++] = ESC;
		line[count++] = '[';
	    }
	    if (rawRow == startSRow && rawCol == startSCol
		&& row == endSRow && col == endSCol) {
		/* Use short-form emacs select */
		line[count++] = 't';
		line[count++] = ' ' + endSCol + 1;
		line[count++] = ' ' + endSRow + 1;
	    } else {
		/* long-form, specify everything */
		line[count++] = 'T';
		line[count++] = ' ' + startSCol + 1;
		line[count++] = ' ' + startSRow + 1;
		line[count++] = ' ' + endSCol + 1;
		line[count++] = ' ' + endSRow + 1;
		line[count++] = ' ' + col + 1;
		line[count++] = ' ' + row + 1;
	    }
	    v_write(screen->respond, line, count);
	    TrackText(0, 0, 0, 0);
	}
    }
    SelectSet(w, event, params, num_params);
    eventMode = NORMAL;
}

void
HandleSelectSet(Widget w,
		XEvent * event,
		String * params,
		Cardinal *num_params)
{
    SelectSet(w, event, params, *num_params);
}

/* ARGSUSED */
static void
SelectSet(Widget w GCC_UNUSED,
	  XEvent * event GCC_UNUSED,
	  String * params,
	  Cardinal num_params)
{
    TRACE(("SelectSet\n"));
    /* Only do select stuff if non-null select */
    if (startSRow != endSRow || startSCol != endSCol) {
	SaltTextAway(startSRow, startSCol, endSRow, endSCol,
		     params, num_params);
    } else {
	DisownSelection(term);
    }
}

#define Abs(x)		((x) < 0 ? -(x) : (x))

/* ARGSUSED */
static void
do_start_extend(Widget w,
		XEvent * event,	/* must be XButtonEvent* */
		String * params GCC_UNUSED,
		Cardinal *num_params GCC_UNUSED,
		Bool use_cursor_loc)
{
    TScreen *screen;
    int row, col, coord;

    if (!IsXtermWidget(w))
	return;

    screen = &((XtermWidget) w)->screen;
    if (SendMousePosition(w, event))
	return;
    firstValidRow = 0;
    lastValidRow = screen->max_row;
#if OPT_READLINE
    if ((KeyModifiers & ShiftMask)
	|| event->xbutton.button != Button3
	|| !(SCREEN_FLAG(screen, dclick3_deletes)))
#endif
	selectUnit = EvalSelectUnit(event->xbutton.time, selectUnit);
    replyToEmacs = False;

#if OPT_READLINE
    CheckSecondPress3(event);
#endif

    if (numberOfClicks == 1
	|| (SCREEN_FLAG(screen, dclick3_deletes)	/* Dclick special */
	    &&!(KeyModifiers & ShiftMask))) {
	/* Save existing selection so we can reestablish it if the guy
	   extends past the other end of the selection */
	saveStartRRow = startERow = startRRow;
	saveStartRCol = startECol = startRCol;
	saveEndRRow = endERow = endRRow;
	saveEndRCol = endECol = endRCol;
    } else {
	/* He just needed the selection mode changed, use old values. */
	startERow = startRRow = saveStartRRow;
	startECol = startRCol = saveStartRCol;
	endERow = endRRow = saveEndRRow;
	endECol = endRCol = saveEndRCol;

    }
    if (use_cursor_loc) {
	row = screen->cursor_row;
	col = screen->cursor_col;
    } else {
	PointToRowCol(event->xbutton.y, event->xbutton.x, &row, &col);
    }
    coord = Coordinate(row, col);

    if (Abs(coord - Coordinate(startSRow, startSCol))
	< Abs(coord - Coordinate(endSRow, endSCol))
	|| coord < Coordinate(startSRow, startSCol)) {
	/* point is close to left side of selection */
	eventMode = LEFTEXTENSION;
	startERow = row;
	startECol = col;
    } else {
	/* point is close to left side of selection */
	eventMode = RIGHTEXTENSION;
	endERow = row;
	endECol = col;
    }
    ComputeSelect(startERow, startECol, endERow, endECol, True);

#if OPT_READLINE
    if (startSRow != endSRow || startSCol != endSCol)
	ExtendingSelection = 1;
#endif
}

static void
ExtendExtend(int row, int col)
{
    int coord = Coordinate(row, col);

    TRACE(("ExtendExtend row=%d, col=%d\n", row, col));
    if (eventMode == LEFTEXTENSION
	&& (coord + (selectUnit != SELECTCHAR)) > Coordinate(endSRow, endSCol)) {
	/* Whoops, he's changed his mind.  Do RIGHTEXTENSION */
	eventMode = RIGHTEXTENSION;
	startERow = saveStartRRow;
	startECol = saveStartRCol;
    } else if (eventMode == RIGHTEXTENSION
	       && coord < Coordinate(startSRow, startSCol)) {
	/* Whoops, he's changed his mind.  Do LEFTEXTENSION */
	eventMode = LEFTEXTENSION;
	endERow = saveEndRRow;
	endECol = saveEndRCol;
    }
    if (eventMode == LEFTEXTENSION) {
	startERow = row;
	startECol = col;
    } else {
	endERow = row;
	endECol = col;
    }
    ComputeSelect(startERow, startECol, endERow, endECol, False);

#if OPT_READLINE
    if (startSRow != endSRow || startSCol != endSCol)
	ExtendingSelection = 1;
#endif
}

void
HandleStartExtend(Widget w,
		  XEvent * event,	/* must be XButtonEvent* */
		  String * params,	/* unused */
		  Cardinal *num_params)		/* unused */
{
    do_start_extend(w, event, params, num_params, False);
}

void
HandleKeyboardStartExtend(Widget w,
			  XEvent * event,	/* must be XButtonEvent* */
			  String * params,	/* unused */
			  Cardinal *num_params)		/* unused */
{
    do_start_extend(w, event, params, num_params, True);
}

void
ScrollSelection(TScreen * screen, int amount, Bool always)
{
    int minrow = -screen->savedlines - screen->topline;
    int maxrow = screen->max_row - screen->topline;
    int maxcol = screen->max_col;

#define scroll_update_one(row, col) \
	row += amount; \
	if (row < minrow) { \
	    row = minrow; \
	    col = 0; \
	} \
	if (row > maxrow) { \
	    row = maxrow; \
	    col = maxcol; \
	}

    scroll_update_one(startRRow, startRCol);
    scroll_update_one(endRRow, endRCol);
    scroll_update_one(startSRow, startSCol);
    scroll_update_one(endSRow, endSCol);

    scroll_update_one(rawRow, rawCol);

    /*
     * If we are told to scroll the selection but it lies outside the scrolling
     * margins, then that could cause the selection to move (bad).  It is not
     * simple to fix, because this function is called both for the scrollbar
     * actions as well as application scrolling.  The 'always' flag is set in
     * the former case.  The rest of the logic handles the latter.
     */
    if (ScrnHaveSelection(screen)) {
	int adjust;

	adjust = screen->startHRow + screen->topline;
	if (always
	    || !ScrnHaveLineMargins(screen)
	    || ScrnIsLineInMargins(screen, adjust)) {
	    scroll_update_one(screen->startHRow, screen->startHCol);
	}
	adjust = screen->endHRow + screen->topline;
	if (always
	    || !ScrnHaveLineMargins(screen)
	    || ScrnIsLineInMargins(screen, adjust)) {
	    scroll_update_one(screen->endHRow, screen->endHCol);
	}
    }

    screen->startHCoord = Coordinate(screen->startHRow, screen->startHCol);
    screen->endHCoord = Coordinate(screen->endHRow, screen->endHCol);
}

/*ARGSUSED*/
void
ResizeSelection(TScreen * screen GCC_UNUSED, int rows, int cols)
{
    rows--;			/* decr to get 0-max */
    cols--;

    if (startRRow > rows)
	startRRow = rows;
    if (startSRow > rows)
	startSRow = rows;
    if (endRRow > rows)
	endRRow = rows;
    if (endSRow > rows)
	endSRow = rows;
    if (rawRow > rows)
	rawRow = rows;

    if (startRCol > cols)
	startRCol = cols;
    if (startSCol > cols)
	startSCol = cols;
    if (endRCol > cols)
	endRCol = cols;
    if (endSCol > cols)
	endSCol = cols;
    if (rawCol > cols)
	rawCol = cols;
}

#if OPT_WIDE_CHARS
Bool
iswide(int i)
{
    return (i == HIDDEN_CHAR) || (my_wcwidth(i) == 2);
}

#define isWideCell(row, col) iswide((int)XTERM_CELL(row, col))
#endif

static void
PointToRowCol(int y,
	      int x,
	      int *r,
	      int *c)
/* Convert pixel coordinates to character coordinates.
   Rows are clipped between firstValidRow and lastValidRow.
   Columns are clipped between to be 0 or greater, but are not clipped to some
       maximum value. */
{
    TScreen *screen = &term->screen;
    int row, col;

    row = (y - screen->border) / FontHeight(screen);
    if (row < firstValidRow)
	row = firstValidRow;
    else if (row > lastValidRow)
	row = lastValidRow;
    col = (x - OriginX(screen)) / FontWidth(screen);
    if (col < 0)
	col = 0;
    else if (col > screen->max_col + 1) {
	col = screen->max_col + 1;
    }
#if OPT_WIDE_CHARS
    /*
     * If we got a click on the right half of a doublewidth character,
     * pretend it happened on the left half.
     */
    if (col > 0
	&& isWideCell(row, col - 1)
	&& (XTERM_CELL(row, col) == HIDDEN_CHAR)) {
	col -= 1;
    }
#endif
    *r = row;
    *c = col;
}

static int
LastTextCol(int row)
{
    TScreen *screen = &term->screen;
    int i;
    Char *ch;

    if ((row += screen->topline) + screen->savedlines >= 0) {
	for (i = screen->max_col,
	     ch = SCRN_BUF_ATTRS(screen, row) + i;
	     i >= 0 && !(*ch & CHARDRAWN);
	     ch--, i--) ;
#if OPT_DEC_CHRSET
	if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, row)[0])) {
	    i *= 2;
	}
#endif
    } else {
	i = -1;
    }
    return (i);
}

#if !OPT_WIDE_CHARS
/*
** double click table for cut and paste in 8 bits
**
** This table is divided in four parts :
**
**	- control characters	[0,0x1f] U [0x80,0x9f]
**	- separators		[0x20,0x3f] U [0xa0,0xb9]
**	- binding characters	[0x40,0x7f] U [0xc0,0xff]
**	- exceptions
*/
/* *INDENT-OFF* */
static int charClass[256] =
{
/* NUL  SOH  STX  ETX  EOT  ENQ  ACK  BEL */
    32,  1,    1,   1,   1,   1,   1,   1,
/*  BS   HT   NL   VT   NP   CR   SO   SI */
     1,  32,   1,   1,   1,   1,   1,   1,
/* DLE  DC1  DC2  DC3  DC4  NAK  SYN  ETB */
     1,   1,   1,   1,   1,   1,   1,   1,
/* CAN   EM  SUB  ESC   FS   GS   RS   US */
     1,   1,   1,   1,   1,   1,   1,   1,
/*  SP    !    "    #    $    %    &    ' */
    32,  33,  34,  35,  36,  37,  38,  39,
/*   (    )    *    +    ,    -    .    / */
    40,  41,  42,  43,  44,  45,  46,  47,
/*   0    1    2    3    4    5    6    7 */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   8    9    :    ;    <    =    >    ? */
    48,  48,  58,  59,  60,  61,  62,  63,
/*   @@    A    B    C    D    E    F    G */
    64,  48,  48,  48,  48,  48,  48,  48,
/*   H    I    J    K    L    M    N    O */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   P    Q    R    S    T    U    V    W */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   X    Y    Z    [    \    ]    ^    _ */
    48,  48,  48,  91,  92,  93,  94,  48,
/*   `    a    b    c    d    e    f    g */
    96,  48,  48,  48,  48,  48,  48,  48,
/*   h    i    j    k    l    m    n    o */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   p    q    r    s    t    u    v    w */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   x    y    z    {    |    }    ~  DEL */
    48,  48,  48, 123, 124, 125, 126,   1,
/* x80  x81  x82  x83  IND  NEL  SSA  ESA */
    1,    1,   1,   1,   1,   1,   1,   1,
/* HTS  HTJ  VTS  PLD  PLU   RI  SS2  SS3 */
    1,    1,   1,   1,   1,   1,   1,   1,
/* DCS  PU1  PU2  STS  CCH   MW  SPA  EPA */
    1,    1,   1,   1,   1,   1,   1,   1,
/* x98  x99  x9A  CSI   ST  OSC   PM  APC */
    1,    1,   1,   1,   1,   1,   1,   1,
/*   -    i   c/    L   ox   Y-    |   So */
    160, 161, 162, 163, 164, 165, 166, 167,
/*  ..   c0   ip   <<    _        R0    - */
    168, 169, 170, 171, 172, 173, 174, 175,
/*   o   +-    2    3    '    u   q|    . */
    176, 177, 178, 179, 180, 181, 182, 183,
/*   ,    1    2   >>  1/4  1/2  3/4    ? */
    184, 185, 186, 187, 188, 189, 190, 191,
/*  A`   A'   A^   A~   A:   Ao   AE   C, */
     48,  48,  48,  48,  48,  48,  48,  48,
/*  E`   E'   E^   E:   I`   I'   I^   I: */
     48,  48,  48,  48,  48,  48,  48,  48,
/*  D-   N~   O`   O'   O^   O~   O:    X */
     48,  48,  48,  48,  48,  48,  48, 215,
/*  O/   U`   U'   U^   U:   Y'    P    B */
     48,  48,  48,  48,  48,  48,  48,  48,
/*  a`   a'   a^   a~   a:   ao   ae   c, */
     48,  48,  48,  48,  48,  48,  48,  48,
/*  e`   e'   e^   e:    i`  i'   i^   i: */
     48,  48,  48,  48,  48,  48,  48,  48,
/*   d   n~   o`   o'   o^   o~   o:   -: */
     48,  48,  48,  48,  48,  48,  48, 247,
/*  o/   u`   u'   u^   u:   y'    P   y: */
     48,  48,  48,  48,  48,  48,  48,  48};
/* *INDENT-ON* */

int
SetCharacterClassRange(int low,	/* in range of [0..255] */
		       int high,
		       int value)	/* arbitrary */
{

    if (low < 0 || high > 255 || high < low)
	return (-1);

    for (; low <= high; low++)
	charClass[low] = value;

    return (0);
}
#endif

#if OPT_WIDE_CHARS
static int
class_of(TScreen * screen, int row, int col)
{
    int value;
#if OPT_DEC_CHRSET
    if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, row + screen->topline)[0])) {
	col /= 2;
    }
#endif
    value = XTERM_CELL(row, col);
    if_OPT_WIDE_CHARS(screen, {
	return CharacterClass(value);
    });
    return CharacterClass(value);
}
#define ClassSelects(screen, row, col, cclass) \
	 (class_of(screen, row, col) == cclass \
	 || XTERM_CELL(row, col) == HIDDEN_CHAR)
#else
#define class_of(screen,row,col) charClass[XTERM_CELL(row, col)]
#define ClassSelects(screen, row, col, cclass) \
	 (class_of(screen,row, col) == cclass)
#endif

/*
 * sets startSRow startSCol endSRow endSCol
 * ensuring that they have legal values
 */
static void
ComputeSelect(int startRow,
	      int startCol,
	      int endRow,
	      int endCol,
	      Bool extend)
{
    TScreen *screen = &term->screen;
    int length;
    int cclass;

    TRACE(("ComputeSelect(startRow=%d, startCol=%d, endRow=%d, endCol=%d, %sextend)\n",
	   startRow, startCol, endRow, endCol, extend ? "" : "no"));

#if OPT_WIDE_CHARS
    if (startCol > 1
	&& isWideCell(startRow, startCol - 1)
	&& XTERM_CELL(startRow, startCol - 0) == HIDDEN_CHAR) {
	fprintf(stderr, "Adjusting start. Changing downwards from %i.\n", startCol);
	startCol -= 1;
	if (endCol == (startCol + 1))
	    endCol--;
    }

    if (endCol > 1
	&& isWideCell(endRow, endCol - 1)
	&& XTERM_CELL(endRow, endCol) == HIDDEN_CHAR) {
	endCol += 1;
    }
#endif

    if (Coordinate(startRow, startCol) <= Coordinate(endRow, endCol)) {
	startSRow = startRRow = startRow;
	startSCol = startRCol = startCol;
	endSRow = endRRow = endRow;
	endSCol = endRCol = endCol;
    } else {			/* Swap them */
	startSRow = startRRow = endRow;
	startSCol = startRCol = endCol;
	endSRow = endRRow = startRow;
	endSCol = endRCol = startCol;
    }

    switch (selectUnit) {
    case SELECTCHAR:
	if (startSCol > (LastTextCol(startSRow) + 1)) {
	    startSCol = 0;
	    startSRow++;
	}
	if (endSCol > (LastTextCol(endSRow) + 1)) {
	    endSCol = 0;
	    endSRow++;
	}
	break;
    case SELECTWORD:
	if (startSCol > (LastTextCol(startSRow) + 1)) {
	    startSCol = 0;
	    startSRow++;
	} else {
	    cclass = class_of(screen, startSRow, startSCol);
	    do {
		--startSCol;
		if (startSCol < 0
		    && ScrnTstWrapped(screen, startSRow - 1)) {
		    --startSRow;
		    startSCol = LastTextCol(startSRow);
		}
	    } while (startSCol >= 0
		     && ClassSelects(screen, startSRow, startSCol, cclass));
	    ++startSCol;
	}

#if OPT_WIDE_CHARS
	if (startSCol && XTERM_CELL(startSRow, startSCol) == HIDDEN_CHAR)
	    startSCol++;
#endif

	if (endSCol > (LastTextCol(endSRow) + 1)) {
	    endSCol = 0;
	    endSRow++;
	} else {
	    length = LastTextCol(endSRow);
	    cclass = class_of(screen, endSRow, endSCol);
	    do {
		++endSCol;
		if (endSCol > length
		    && ScrnTstWrapped(screen, endSRow)) {
		    endSCol = 0;
		    ++endSRow;
		    length = LastTextCol(endSRow);
		}
	    } while (endSCol <= length
		     && ClassSelects(screen, endSRow, endSCol, cclass));
	    /* Word select selects if pointing to any char
	       in "word", especially in that it includes
	       the last character in a word.  So no --endSCol
	       and do special eol handling */
	    if (endSCol > length + 1) {
		endSCol = 0;
		++endSRow;
	    }
	}

#if OPT_WIDE_CHARS
	if (endSCol && XTERM_CELL(endSRow, endSCol) == HIDDEN_CHAR)
	    endSCol++;
#endif

	saveStartWRow = startSRow;
	saveStartWCol = startSCol;
	break;
    case SELECTLINE:
	while (ScrnTstWrapped(screen, endSRow)) {
	    ++endSRow;
	}
	if (term->screen.cutToBeginningOfLine
	    || startSRow < saveStartWRow) {
	    startSCol = 0;
	    while (ScrnTstWrapped(screen, startSRow - 1)) {
		--startSRow;
	    }
	} else if (!extend) {
	    if ((startRow < saveStartWRow)
		|| (startRow == saveStartWRow
		    && startCol < saveStartWCol)) {
		startSCol = 0;
		while (ScrnTstWrapped(screen, startSRow - 1)) {
		    --startSRow;
		}
	    } else {
		startSRow = saveStartWRow;
		startSCol = saveStartWCol;
	    }
	}
	if (term->screen.cutNewline) {
	    endSCol = 0;
	    ++endSRow;
	} else {
	    endSCol = LastTextCol(endSRow) + 1;
	}
	break;
    }

    /* check boundaries */
    ScrollSelection(screen, 0, False);

    TrackText(startSRow, startSCol, endSRow, endSCol);
    return;
}

void
TrackText(int frow,
	  int fcol,
	  int trow,
	  int tcol)
    /* Guaranteed (frow, fcol) <= (trow, tcol) */
{
    int from, to;
    TScreen *screen = &term->screen;
    int old_startrow, old_startcol, old_endrow, old_endcol;

    TRACE(("TrackText(frow=%d, fcol=%d, trow=%d, tcol=%d)\n",
	   frow, fcol, trow, tcol));

    old_startrow = screen->startHRow;
    old_startcol = screen->startHCol;
    old_endrow = screen->endHRow;
    old_endcol = screen->endHCol;
    if (frow == old_startrow && fcol == old_startcol &&
	trow == old_endrow && tcol == old_endcol)
	return;
    screen->startHRow = frow;
    screen->startHCol = fcol;
    screen->endHRow = trow;
    screen->endHCol = tcol;
    from = Coordinate(frow, fcol);
    to = Coordinate(trow, tcol);
    if (to <= screen->startHCoord || from > screen->endHCoord) {
	/* No overlap whatsoever between old and new hilite */
	ReHiliteText(old_startrow, old_startcol, old_endrow, old_endcol);
	ReHiliteText(frow, fcol, trow, tcol);
    } else {
	if (from < screen->startHCoord) {
	    /* Extend left end */
	    ReHiliteText(frow, fcol, old_startrow, old_startcol);
	} else if (from > screen->startHCoord) {
	    /* Shorten left end */
	    ReHiliteText(old_startrow, old_startcol, frow, fcol);
	}
	if (to > screen->endHCoord) {
	    /* Extend right end */
	    ReHiliteText(old_endrow, old_endcol, trow, tcol);
	} else if (to < screen->endHCoord) {
	    /* Shorten right end */
	    ReHiliteText(trow, tcol, old_endrow, old_endcol);
	}
    }
    screen->startHCoord = from;
    screen->endHCoord = to;
}

static void
ReHiliteText(int frow,
	     int fcol,
	     int trow,
	     int tcol)
    /* Guaranteed that (frow, fcol) <= (trow, tcol) */
{
    TScreen *screen = &term->screen;
    int i;

    TRACE(("ReHiliteText from %d.%d to %d.%d\n", frow, fcol, trow, tcol));

    if (frow < 0)
	frow = fcol = 0;
    else if (frow > screen->max_row)
	return;			/* nothing to do, since trow >= frow */

    if (trow < 0)
	return;			/* nothing to do, since frow <= trow */
    else if (trow > screen->max_row) {
	trow = screen->max_row;
	tcol = screen->max_col + 1;
    }
    if (frow == trow && fcol == tcol)
	return;

    if (frow != trow) {		/* do multiple rows */
	if ((i = screen->max_col - fcol + 1) > 0) {	/* first row */
	    ScrnRefresh(screen, frow, fcol, 1, i, True);
	}
	if ((i = trow - frow - 1) > 0) {	/* middle rows */
	    ScrnRefresh(screen, frow + 1, 0, i, screen->max_col + 1, True);
	}
	if (tcol > 0 && trow <= screen->max_row) {	/* last row */
	    ScrnRefresh(screen, trow, 0, 1, tcol, True);
	}
    } else {			/* do single row */
	ScrnRefresh(screen, frow, fcol, 1, tcol - fcol, True);
    }
}

static void
SaltTextAway(int crow, int ccol, int row, int col,
	     String * params,	/* selections */
	     Cardinal num_params)
    /* Guaranteed that (crow, ccol) <= (row, col), and that both points are valid
       (may have row = screen->max_row+1, col = 0) */
{
    TScreen *screen = &term->screen;
    int i, j = 0;
    int eol;
    Char *line;
    Char *lp;

    if (crow == row && ccol > col) {
	int tmp = ccol;
	ccol = col;
	col = tmp;
    }

    --col;
    /* first we need to know how long the string is before we can save it */

    if (row == crow) {
	j = Length(screen, crow, ccol, col);
    } else {			/* two cases, cut is on same line, cut spans multiple lines */
	j += Length(screen, crow, ccol, screen->max_col) + 1;
	for (i = crow + 1; i < row; i++)
	    j += Length(screen, i, 0, screen->max_col) + 1;
	if (col >= 0)
	    j += Length(screen, row, 0, col);
    }

    /* UTF-8 may require more space */
    if_OPT_WIDE_CHARS(screen, {
	j *= 4;
    });

    /* now get some memory to save it in */

    if (screen->selection_size <= j) {
	if ((line = (Char *) malloc((unsigned) j + 1)) == 0)
	    SysError(ERROR_BMALLOC2);
	XtFree((char *) screen->selection_data);
	screen->selection_data = line;
	screen->selection_size = j + 1;
    } else {
	line = screen->selection_data;
    }

    if ((line == 0)
	|| (j < 0))
	return;

    line[j] = '\0';		/* make sure it is null terminated */
    lp = line;			/* lp points to where to save the text */
    if (row == crow) {
	lp = SaveText(screen, row, ccol, col, lp, &eol);
    } else {
	lp = SaveText(screen, crow, ccol, screen->max_col, lp, &eol);
	if (eol)
	    *lp++ = '\n';	/* put in newline at end of line */
	for (i = crow + 1; i < row; i++) {
	    lp = SaveText(screen, i, 0, screen->max_col, lp, &eol);
	    if (eol)
		*lp++ = '\n';
	}
	if (col >= 0)
	    lp = SaveText(screen, row, 0, col, lp, &eol);
    }
    *lp = '\0';			/* make sure we have end marked */

    TRACE(("Salted TEXT:%d:%.*s\n", lp - line, lp - line, line));
    screen->selection_length = (lp - line);
    _OwnSelection(term, params, num_params);
}

static Bool
_ConvertSelectionHelper(Widget w,
			Atom * type, XtPointer *value,
			unsigned long *length, int *format,
			int (*conversion_function) (Display *,
						    char **, int,
						    XICCEncodingStyle,
						    XTextProperty *),
			XICCEncodingStyle conversion_style)
{
    Display *d = XtDisplay(w);
    TScreen *screen;
    XTextProperty textprop;

    if (!IsXtermWidget(w))
	return False;

    screen = &((XtermWidget) w)->screen;

    if (conversion_function(d, (char **) &screen->selection_data, 1,
			    conversion_style,
			    &textprop) < Success)
	return False;
    *value = (XtPointer) textprop.value;
    *length = textprop.nitems;
    *type = textprop.encoding;
    *format = textprop.format;
    return True;
}

static Boolean
ConvertSelection(Widget w,
		 Atom * selection,
		 Atom * target,
		 Atom * type,
		 XtPointer *value,
		 unsigned long *length,
		 int *format)
{
    Display *d = XtDisplay(w);
    TScreen *screen;
    Bool result = False;

    if (!IsXtermWidget(w))
	return False;

    screen = &((XtermWidget) w)->screen;

    if (screen->selection_data == NULL)
	return False;		/* can this happen? */

    if (*target == XA_TARGETS(d)) {
	Atom *targetP;
	Atom *std_targets;
	XPointer std_return = 0;
	unsigned long std_length;
	if (XmuConvertStandardSelection(w, screen->selection_time, selection,
					target, type, &std_return,
					&std_length, format)) {
	    std_targets = (Atom *) (std_return);
	    *length = std_length + 6;
	    targetP = (Atom *) XtMalloc(sizeof(Atom) * (*length));
	    *value = (XtPointer) targetP;
	    *targetP++ = XA_STRING;
	    *targetP++ = XA_TEXT(d);
#ifdef X_HAVE_UTF8_STRING
	    *targetP++ = XA_COMPOUND_TEXT(d);
	    *targetP++ = XA_UTF8_STRING(d);
#else
	    *targetP = XA_COMPOUND_TEXT(d);
	    if_OPT_WIDE_CHARS(screen, {
		*targetP = XA_UTF8_STRING(d);
	    });
	    targetP++;
#endif
	    *targetP++ = XA_LENGTH(d);
	    *targetP++ = XA_LIST_LENGTH(d);
	    memcpy(targetP, std_targets, sizeof(Atom) * std_length);
	    XtFree((char *) std_targets);
	    *type = XA_ATOM;
	    *format = 32;
	    result = True;
	}
    }
#if OPT_WIDE_CHARS
    else if (screen->wide_chars && *target == XA_STRING) {
	result =
	    _ConvertSelectionHelper(w,
				    type, value, length, format,
				    Xutf8TextListToTextProperty,
				    XStringStyle);
    } else if (screen->wide_chars && *target == XA_UTF8_STRING(d)) {
	result =
	    _ConvertSelectionHelper(w,
				    type, value, length, format,
				    Xutf8TextListToTextProperty,
				    XUTF8StringStyle);
    } else if (screen->wide_chars && *target == XA_TEXT(d)) {
	result =
	    _ConvertSelectionHelper(w,
				    type, value, length, format,
				    Xutf8TextListToTextProperty,
				    XStdICCTextStyle);
    } else if (screen->wide_chars && *target == XA_COMPOUND_TEXT(d)) {
	result =
	    _ConvertSelectionHelper(w,
				    type, value, length, format,
				    Xutf8TextListToTextProperty,
				    XCompoundTextStyle);
    }
#endif

    else if (*target == XA_STRING) {	/* not wide_chars */
	/* We can only reach this point if the selection requestor
	   requested STRING before any of TEXT, COMPOUND_TEXT or
	   UTF8_STRING.  We therefore assume that the requestor is not
	   properly internationalised, and dump raw eight-bit data
	   with no conversion into the selection.  Yes, this breaks
	   the ICCCM in non-Latin-1 locales. */
	*type = XA_STRING;
	*value = (XtPointer) screen->selection_data;
	*length = screen->selection_length;
	*format = 8;
	result = True;
    } else if (*target == XA_TEXT(d)) {		/* not wide_chars */
	result =
	    _ConvertSelectionHelper(w,
				    type, value, length, format,
				    XmbTextListToTextProperty,
				    XStdICCTextStyle);
    } else if (*target == XA_COMPOUND_TEXT(d)) {	/* not wide_chars */
	result =
	    _ConvertSelectionHelper(w,
				    type, value, length, format,
				    XmbTextListToTextProperty,
				    XCompoundTextStyle);
    }
#ifdef X_HAVE_UTF8_STRING
    else if (*target == XA_UTF8_STRING(d)) {	/* not wide_chars */
	result =
	    _ConvertSelectionHelper(w,
				    type, value, length, format,
				    XmbTextListToTextProperty,
				    XUTF8StringStyle);
    }
#endif
    else if (*target == XA_LIST_LENGTH(d)) {
	*value = XtMalloc(4);
	if (sizeof(long) == 4)
	     *(long *) *value = 1;
	else {
	    long temp = 1;
	    memcpy((char *) *value, ((char *) &temp) + sizeof(long) - 4, 4);
	}
	*type = XA_INTEGER;
	*length = 1;
	*format = 32;
	result = True;
    } else if (*target == XA_LENGTH(d)) {
	/* This value is wrong if we have UTF-8 text */
	*value = XtMalloc(4);
	if (sizeof(long) == 4) {
	    *(long *) *value = screen->selection_length;
	} else {
	    long temp = screen->selection_length;
	    memcpy((char *) *value, ((char *) &temp) + sizeof(long) - 4, 4);
	}
	*type = XA_INTEGER;
	*length = 1;
	*format = 32;
	result = True;
    } else if (XmuConvertStandardSelection(w,
					   screen->selection_time, selection,
					   target, type, (XPointer *) value,
					   length, format)) {
	result = True;
    }

    /* else */
    return result;
}

static void
LoseSelection(Widget w, Atom * selection)
{
    TScreen *screen;
    Atom *atomP;
    Cardinal i;

    if (!IsXtermWidget(w))
	return;

    screen = &((XtermWidget) w)->screen;
    for (i = 0, atomP = screen->selection_atoms;
	 i < screen->selection_count; i++, atomP++) {
	if (*selection == *atomP)
	    *atomP = (Atom) 0;
	if (CutBuffer(*atomP) >= 0) {
	    *atomP = (Atom) 0;
	}
    }

    for (i = screen->selection_count; i; i--) {
	if (screen->selection_atoms[i - 1] != 0)
	    break;
    }
    screen->selection_count = i;

    for (i = 0, atomP = screen->selection_atoms;
	 i < screen->selection_count; i++, atomP++) {
	if (*atomP == (Atom) 0) {
	    *atomP = screen->selection_atoms[--screen->selection_count];
	}
    }

    if (screen->selection_count == 0)
	TrackText(0, 0, 0, 0);
}

/* ARGSUSED */
static void
SelectionDone(Widget w GCC_UNUSED,
	      Atom * selection GCC_UNUSED,
	      Atom * target GCC_UNUSED)
{
    /* empty proc so Intrinsics know we want to keep storage */
}

static void
_OwnSelection(XtermWidget termw,
	      String * selections,
	      Cardinal count)
{
    Atom *atoms = termw->screen.selection_atoms;
    Cardinal i;
    Bool have_selection = False;

    if (termw->screen.selection_length < 0)
	return;

    if (count > termw->screen.sel_atoms_size) {
	XtFree((char *) atoms);
	atoms = (Atom *) XtMalloc(count * sizeof(Atom));
	termw->screen.selection_atoms = atoms;
	termw->screen.sel_atoms_size = count;
    }
    XmuInternStrings(XtDisplay((Widget) termw), selections, count, atoms);
    for (i = 0; i < count; i++) {
	int cutbuffer = CutBuffer(atoms[i]);
	if (cutbuffer >= 0) {
	    if (termw->screen.selection_length >
		4 * XMaxRequestSize(XtDisplay((Widget) termw)) - 32) {
		fprintf(stderr,
			"%s: selection too big (%d bytes), not storing in CUT_BUFFER%d\n",
			xterm_name, termw->screen.selection_length, cutbuffer);
	    } else {
		/* This used to just use the UTF-8 data, which was totally
		 * broken as not even the corresponding paste code in Xterm
		 * understood this!  So now it converts to Latin1 first.
		 *   Robert Brady, 2000-09-05
		 */
		unsigned long length = termw->screen.selection_length;
		Char *data = termw->screen.selection_data;
		if_OPT_WIDE_CHARS((&(termw->screen)), {
		    data = UTF8toLatin1(data, length, &length);
		});
		TRACE(("XStoreBuffer(%d)\n", cutbuffer));
		XStoreBuffer(XtDisplay((Widget) termw),
			     (char *) data,
			     (int) length,
			     cutbuffer);
	    }
	} else if (!replyToEmacs) {
	    have_selection |=
		XtOwnSelection((Widget) termw, atoms[i],
			       termw->screen.selection_time,
			       ConvertSelection, LoseSelection, SelectionDone);
	}
    }
    if (!replyToEmacs)
	termw->screen.selection_count = count;
    if (!have_selection)
	TrackText(0, 0, 0, 0);
}

static void
ResetSelectionState(TScreen * screen)
{
    screen->selection_count = 0;
    screen->startHRow = screen->startHCol = 0;
    screen->endHRow = screen->endHCol = 0;
}

void
DisownSelection(XtermWidget termw)
{
    TScreen *screen = &(termw->screen);
    Atom *atoms = screen->selection_atoms;
    Cardinal count = screen->selection_count;
    Cardinal i;

    TRACE(("DisownSelection count %d, start %d.%d, end %d.%d\n",
	   count,
	   screen->startHRow,
	   screen->startHCol,
	   screen->endHRow,
	   screen->endHCol));

    for (i = 0; i < count; i++) {
	int cutbuffer = CutBuffer(atoms[i]);
	if (cutbuffer < 0) {
	    XtDisownSelection((Widget) termw, atoms[i],
			      screen->selection_time);
	}
    }
    /*
     * If none of the callbacks via XtDisownSelection() reset highlighting
     * do it now.
     */
    if (ScrnHaveSelection(screen)) {
	/* save data which will be reset */
	int start_row = screen->startHRow;
	int start_col = screen->startHCol;
	int end_row = screen->endHRow;
	int end_col = screen->endHCol;

	ResetSelectionState(screen);
	ReHiliteText(start_row, start_col, end_row, end_col);
    } else {
	ResetSelectionState(screen);
    }
}

/* returns number of chars in line from scol to ecol out */
/* ARGSUSED */
static int
Length(TScreen * screen GCC_UNUSED,
       int row,
       int scol,
       int ecol)
{
    int lastcol = LastTextCol(row);

    if (ecol > lastcol)
	ecol = lastcol;
    return (ecol - scol + 1);
}

/* copies text into line, preallocated */
static Char *
SaveText(TScreen * screen,
	 int row,
	 int scol,
	 int ecol,
	 Char * lp,		/* pointer to where to put the text */
	 int *eol)
{
    int i = 0;
    unsigned c;
    Char *result = lp;
#if OPT_WIDE_CHARS
    int previous = 0;
    unsigned c_1 = 0, c_2 = 0;
#endif

    i = Length(screen, row, scol, ecol);
    ecol = scol + i;
#if OPT_DEC_CHRSET
    if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, row + screen->topline)[0])) {
	scol = (scol + 0) / 2;
	ecol = (ecol + 1) / 2;
    }
#endif
    *eol = !ScrnTstWrapped(screen, row);
    for (i = scol; i < ecol; i++) {
	c = E2A(XTERM_CELL(row, i));
#if OPT_WIDE_CHARS
	if (screen->utf8_mode) {
	    c_1 = E2A(XTERM_CELL_C1(row, i));
	    c_2 = E2A(XTERM_CELL_C2(row, i));
	}

	/* We want to strip out every occurrence of HIDDEN_CHAR AFTER a
	 * wide character.
	 */
	if (c == HIDDEN_CHAR && iswide(previous)) {
	    previous = c;
	    /* Combining characters attached to double-width characters
	       are in memory attached to the HIDDEN_CHAR */
	    if (c_1) {
		lp = convertToUTF8(lp, c_1);
		if (c_2)
		    lp = convertToUTF8(lp, c_2);
	    }
	    continue;
	}
	previous = c;
	if (screen->utf8_mode) {
	    lp = convertToUTF8(lp, (c != 0) ? c : ' ');
	    if (c_1) {
		lp = convertToUTF8(lp, c_1);
		if (c_2)
		    lp = convertToUTF8(lp, c_2);
	    }
	} else
#endif
	{
	    if (c == 0) {
		c = E2A(' ');
	    } else if (c < E2A(' ')) {
		if (c == XPOUND)
		    c = 0x23;	/* char on screen is pound sterling */
		else
		    c += 0x5f;	/* char is from DEC drawing set */
	    } else if (c == 0x7f) {
		c = 0x5f;
	    }
	    *lp++ = A2E(c);
	}
	if (c != E2A(' '))
	    result = lp;
    }

    /*
     * If requested, trim trailing blanks from selected lines.  Do not do this
     * if the line is wrapped.
     */
    if (!*eol || !screen->trim_selection)
	result = lp;

    return (result);
}

static int
BtnCode(XButtonEvent * event, int button)
{
    int result = 32 + (KeyState(event->state) << 2);

    if (button < 0 || button > 5) {
	result += 3;
    } else {
	if (button > 3)
	    result += (64 - 4);
	if (event->type == MotionNotify)
	    result += 32;
	result += button;
    }
    return result;
}

#define MOUSE_LIMIT (255 - 32)

static void
EditorButton(XButtonEvent * event)
{
    TScreen *screen = &term->screen;
    int pty = screen->respond;
    Char line[6];
    int row, col;
    int button;
    unsigned count = 0;

    /* If button event, get button # adjusted for DEC compatibility */
    button = event->button - 1;
    if (button >= 3)
	button++;

    /* Compute character position of mouse pointer */
    row = (event->y - screen->border) / FontHeight(screen);
    col = (event->x - OriginX(screen)) / FontWidth(screen);

    /* Limit to screen dimensions */
    if (row < 0)
	row = 0;
    else if (row > screen->max_row)
	row = screen->max_row;
    else if (row > MOUSE_LIMIT)
	row = MOUSE_LIMIT;

    if (col < 0)
	col = 0;
    else if (col > screen->max_col)
	col = screen->max_col;
    else if (col > MOUSE_LIMIT)
	col = MOUSE_LIMIT;

    /* Build key sequence starting with \E[M */
    if (screen->control_eight_bits) {
	line[count++] = CSI;
    } else {
	line[count++] = ESC;
	line[count++] = '[';
    }
    line[count++] = 'M';

    /* Add event code to key sequence */
    if (screen->send_mouse_pos == X10_MOUSE) {
	line[count++] = ' ' + button;
    } else {
	/* Button-Motion events */
	switch (event->type) {
	case ButtonPress:
	    line[count++] = BtnCode(event, screen->mouse_button = button);
	    break;
	case ButtonRelease:
	    /*
	     * Wheel mouse interface generates release-events for buttons
	     * 4 and 5, coded here as 3 and 4 respectively.  We change the
	     * release for buttons 1..3 to a -1.
	     */
	    if (button < 3)
		button = -1;
	    line[count++] = BtnCode(event, screen->mouse_button = button);
	    break;
	case MotionNotify:
	    /* BTN_EVENT_MOUSE and ANY_EVENT_MOUSE modes send motion
	     * events only if character cell has changed.
	     */
	    if ((row == screen->mouse_row)
		&& (col == screen->mouse_col))
		return;
	    line[count++] = BtnCode(event, screen->mouse_button);
	    break;
	default:
	    return;
	}
    }

    screen->mouse_row = row;
    screen->mouse_col = col;

    /* Add pointer position to key sequence */
    line[count++] = ' ' + col + 1;
    line[count++] = ' ' + row + 1;

    TRACE(("mouse at %d,%d button+mask = %#x\n", row, col,
	   (screen->control_eight_bits) ? line[2] : line[3]));

    /* Transmit key sequence to process running under xterm */
    v_write(pty, line, count);
}

/*ARGSUSED*/
#if OPT_TEK4014
void
HandleGINInput(Widget w GCC_UNUSED,
	       XEvent * event GCC_UNUSED,
	       String * param_list,
	       Cardinal *nparamsp)
{
    if (term->screen.TekGIN && *nparamsp == 1) {
	int c = param_list[0][0];
	switch (c) {
	case 'l':
	case 'm':
	case 'r':
	case 'L':
	case 'M':
	case 'R':
	    break;
	default:
	    Bell(XkbBI_MinorError, 0);	/* let them know they goofed */
	    c = 'l';		/* provide a default */
	}
	TekEnqMouse(c | 0x80);
	TekGINoff();
    } else {
	Bell(XkbBI_MinorError, 0);
    }
}
#endif /* OPT_TEK4014 */

/* ARGSUSED */
void
HandleSecure(Widget w GCC_UNUSED,
	     XEvent * event,	/* unused */
	     String * params GCC_UNUSED,	/* [0] = volume */
	     Cardinal *param_count GCC_UNUSED)	/* 0 or 1 */
{
    Time ev_time = CurrentTime;

    if ((event->xany.type == KeyPress) ||
	(event->xany.type == KeyRelease))
	ev_time = event->xkey.time;
    else if ((event->xany.type == ButtonPress) ||
	     (event->xany.type == ButtonRelease))
	ev_time = event->xbutton.time;
    DoSecureKeyboard(ev_time);
}
@


1.3
log
@revert to xterm-200-based (plus fix an openbsd glitch)
xterm-215-based does not work correctly:
* uxterm does not honour its class (e.g. my font is too small)
* utmp is never updated
@
text
@d321 1
d374 1
d446 1
d465 1
d507 1
d576 1
d634 1
d801 2
a802 1
	v_write(screen->respond, line, 3);
d816 2
a817 1
	v_write(screen->respond, "\177", 1);	/* XXX Sometimes "\08"? */
d898 2
a899 1
	v_write(screen->respond, Line, 3);
d924 1
a924 1
	    v_write(pty, Line, 1);
d933 2
a934 1
		v_write(pty, Line, 1);
d1290 1
d1292 2
a1293 1
#  define tty_vwrite(pty,lag,l)		v_write(pty,lag,l)
d1308 1
d1366 1
@


1.2
log
@merge and go back to xterm-215
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.246 2006/06/19 00:36:50 tom Exp $ */
d3 1
d5 1
a5 1
 * Copyright 1999-2005,2006 by Thomas E. Dickey
d55 1
a55 1
/* $XFree86: xc/programs/xterm/button.c,v 3.88 2006/06/19 00:36:50 dickey Exp $ */
a78 10
#include <xstrings.h>

#if OPT_SELECT_REGEX
#ifdef HAVE_PCREPOSIX_H
#include <pcreposix.h>
#else /* POSIX regex.h */
#include <sys/types.h>
#include <regex.h>
#endif
#endif
a80 1
#include <ctype.h>
d87 4
d109 19
a127 1
#define	Coordinate(s,c)	((c)->row * MaxCols(s) + (c)->col)
d129 2
a130 2
static const CELL zeroCELL =
{0, 0};
d132 5
a136 4
#if OPT_DEC_LOCATOR
static Bool SendLocatorPosition(XtermWidget xw, XEvent * event);
static void CheckLocatorPosition(XtermWidget xw, XEvent * event);
#endif /* OPT_DEC_LOCATOR */
d139 3
d147 1
a147 1
static CELL lastButton3;	/* At the release time */
d150 13
a162 2
static Char *SaveText(TScreen * screen, int row, int scol, int ecol,
		      Char * lp, int *eol);
d164 4
a167 3
static void ComputeSelect(TScreen * screen, CELL * startc, CELL * endc, Bool extend);
static void EditorButton(TScreen * screen, XButtonEvent * event);
static void EndExtend(XtermWidget w, XEvent * event, String * params, Cardinal
d169 6
a174 6
static void ExtendExtend(TScreen * screen, const CELL * cell);
static void PointToCELL(TScreen * screen, int y, int x, CELL * cell);
static void ReHiliteText(TScreen * screen, CELL * first, CELL * last);
static void SaltTextAway(XtermWidget xw, CELL * cellc, CELL * cell,
			 String * params, Cardinal num_params);
static void SelectSet(XtermWidget xw, XEvent * event, String * params, Cardinal num_params);
d176 4
a179 5
static void StartSelect(TScreen * screen, const CELL * cell);
static void TrackDown(TScreen * screen, XButtonEvent * event);
static void TrackText(TScreen * screen, const CELL * first, const CELL * last);
static void _OwnSelection(XtermWidget xw, String * selections, Cardinal count);
static void do_select_end(XtermWidget xw, XEvent * event, String * params,
d183 1
a183 1
SendMousePosition(XtermWidget xw, XEvent * event)
d185 6
a190 1
    TScreen *screen = &(xw->screen);
d198 1
a198 1
	return (SendLocatorPosition(xw, event));
d214 1
a214 1
		EditorButton(screen, (XButtonEvent *) event);
d223 1
a223 1
	    TrackDown(screen, (XButtonEvent *) event);
d227 1
a227 1
	    EditorButton(screen, (XButtonEvent *) event);
d239 1
a239 1
	    EditorButton(screen, (XButtonEvent *) event);
d276 2
a277 2
static Bool
SendLocatorPosition(XtermWidget xw, XEvent * event)
d279 1
a279 2
    ANSI reply;
    TScreen *screen = &(xw->screen);
d299 1
a299 1
	CheckLocatorPosition(xw, event);
a312 1
    memset(&reply, 0, sizeof(reply));
d323 1
a323 1
	    MotionOff(screen, xw);
d375 1
a375 1
	MotionOff(screen, xw);
d387 1
a387 1
	MotionOff(screen, xw);
d407 1
a407 1
GetLocatorPosition(XtermWidget xw)
d409 1
a409 2
    ANSI reply;
    TScreen *screen = &xw->screen;
d426 1
a426 1
	MotionOff(screen, xw);
a428 1
    memset(&reply, 0, sizeof(reply));
d446 1
a446 1
	    MotionOff(screen, xw);
d464 1
a464 1
	MotionOff(screen, xw);
d470 1
a470 1
InitLocatorFilter(XtermWidget xw)
d472 1
a472 2
    ANSI reply;
    TScreen *screen = &xw->screen;
a496 1
	    memset(&reply, 0, sizeof(reply));
d505 1
a505 1
		MotionOff(screen, xw);
d514 1
a514 1
	    MotionOn(screen, xw);
a561 1
	memset(&reply, 0, sizeof(reply));
d573 1
a573 1
	    MotionOff(screen, xw);
d584 1
a584 1
    MotionOn(screen, xw);
d587 2
a588 2
static void
CheckLocatorPosition(XtermWidget xw, XEvent * event)
d590 1
a590 2
    ANSI reply;
    TScreen *screen = &(xw->screen);
d609 1
a609 1
	MotionOff(screen, xw);
a610 1
	memset(&reply, 0, sizeof(reply));
d630 1
a630 1
	    MotionOff(screen, xw);
d639 1
a639 1
isClick1_clean(TScreen * screen, XEvent * event)
d641 1
a649 1

d652 3
a654 6

    if (lastButtonDownTime == (Time) 0) {
	/* first time or once in a blue moon */
	delta = screen->multiClickTime + 1;
    } else if (event->xbutton.time > lastButtonDownTime) {
	/* most of the time */
d656 1
a656 2
    } else {
	/* time has rolled over since lastButtonUpTime */
d658 1
a658 3
    }

    return delta <= screen->multiClickTime;
d662 1
a662 1
isDoubleClick3(TScreen * screen, XEvent * event)
d673 4
a676 5
    if (lastButton3DoubleDownTime == (Time) 0) {
	/* No previous click or once in a blue moon */
	delta = screen->multiClickTime + 1;
    } else if (event->xbutton.time > lastButton3DoubleDownTime) {
	/* most of the time */
d678 1
a678 2
    } else {
	/* time has rolled over since lastButton3DoubleDownTime */
d680 1
a680 2
    }
    if (delta <= screen->multiClickTime) {
d682 1
a682 1
	CELL cell;
d685 2
a686 2
	PointToCELL(screen, event->xbutton.y, event->xbutton.x, &cell);
	if (isSameCELL(&cell, &lastButton3)) {
d693 2
a694 1
    PointToCELL(screen, event->xbutton.y, event->xbutton.x, &lastButton3);
d699 1
a699 1
CheckSecondPress3(TScreen * screen, XEvent * event)
d701 1
a701 1
    int delta;
d710 4
a713 5
    if (lastButton3UpTime == (Time) 0) {
	/* No previous click or once in a blue moon */
	delta = screen->multiClickTime + 1;
    } else if (event->xbutton.time > lastButton3UpTime) {
	/* most of the time */
d715 1
a715 2
    } else {
	/* time has rolled over since lastButton3UpTime */
d717 3
a719 6
    }
    if (delta <= screen->multiClickTime) {
	CELL cell;

	PointToCELL(screen, event->xbutton.y, event->xbutton.x, &cell);
	if (isSameCELL(&cell, &lastButton3)) {
d722 2
a723 1
	    PointToCELL(screen, event->xbutton.y, event->xbutton.x, &lastButton3);
d734 1
a734 3
rowOnCurrentLine(TScreen * screen,
		 int line,
		 int *deltap)	/* must be XButtonEvent */
d736 1
d757 1
a757 1
eventRow(TScreen * screen, XEvent * event)	/* must be XButtonEvent */
d759 2
d765 1
a765 1
eventColBetween(TScreen * screen, XEvent * event)	/* must be XButtonEvent */
d767 2
d775 1
a775 1
ReadLineMovePoint(TScreen * screen, int col, int ldelta)
d777 1
d781 1
a781 1
    col += ldelta * MaxCols(screen) - screen->cur_col;
d799 1
a799 1
ReadLineDelete(TScreen * screen, CELL * cell1, CELL * cell2)
d801 1
d804 1
a804 1
    del = (cell2->col - cell1->col) + ((cell2->row - cell1->row) * MaxCols(screen));
d808 1
a808 1
	v_write(screen->respond, (Char *) "\177", 1);
d815 1
a815 1
DiredButton(Widget w,
d820 13
a832 16
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
	TScreen *screen = &(xw->screen);
	Char Line[6];
	unsigned line, col;

	if (event->type == ButtonPress || event->type == ButtonRelease) {
	    line = (event->xbutton.y - screen->border) / FontHeight(screen);
	    col = (event->xbutton.x - OriginX(screen)) / FontWidth(screen);
	    Line[0] = CONTROL('X');
	    Line[1] = ESC;
	    Line[2] = 'G';
	    Line[3] = ' ' + col;
	    Line[4] = ' ' + line;
	    v_write(screen->respond, Line, 5);
	}
d838 1
a838 1
ReadLineButton(Widget w,
d843 3
a845 28
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
	TScreen *screen = &(xw->screen);
	Char Line[6];
	int line, col, ldelta = 0;

	if (!(event->type == ButtonPress || event->type == ButtonRelease)
	    || (screen->send_mouse_pos != MOUSE_OFF) || ExtendingSelection)
	    goto finish;
	if (event->type == ButtonRelease) {
	    int delta;

	    if (lastButtonDownTime == (Time) 0) {
		/* first time and once in a blue moon */
		delta = screen->multiClickTime + 1;
	    } else if (event->xbutton.time > lastButtonDownTime) {
		/* most of the time */
		delta = event->xbutton.time - lastButtonDownTime;
	    } else {
		/* time has rolled over since lastButtonUpTime */
		delta = (((Time) ~ 0) - lastButtonDownTime) + event->xbutton.time;
	    }
	    if (delta > screen->multiClickTime)
		goto finish;	/* All this work for this... */
	}
	line = (event->xbutton.y - screen->border) / FontHeight(screen);
	if (line != screen->cur_row) {
	    int l1, l2;
d847 29
a875 28
	    if (line < screen->cur_row)
		l1 = line, l2 = screen->cur_row;
	    else
		l2 = line, l1 = screen->cur_row;
	    l1--;
	    while (++l1 < l2)
		if (!ScrnTstWrapped(screen, l1))
		    goto finish;
	    /* Everything is on one "wrapped line" now */
	    ldelta = line - screen->cur_row;
	}
	/* Correct by half a width - we are acting on a boundary, not on a cell. */
	col = (event->xbutton.x - OriginX(screen) + (FontWidth(screen) - 1)
	       / 2)
	    / FontWidth(screen) - screen->cur_col + ldelta * MaxCols(screen);
	if (col == 0)
	    goto finish;
	Line[0] = ESC;
	/* XXX: sometimes it is better to send '['? */
	Line[1] = 'O';
	Line[2] = (col > 0 ? 'C' : 'D');
	if (col < 0)
	    col = -col;
	while (col--)
	    v_write(screen->respond, Line, 3);
      finish:
	if (event->type == ButtonRelease)
	    do_select_end(xw, event, params, num_params, False);
d877 16
d898 1
a898 1
ViButton(Widget w,
d903 6
a908 14
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
	TScreen *screen = &(xw->screen);
	int pty = screen->respond;
	Char Line[6];
	int line;

	if (event->type == ButtonPress || event->type == ButtonRelease) {

	    line = screen->cur_row -
		((event->xbutton.y - screen->border) / FontHeight(screen));
	    if (line != 0) {
		Line[0] = ESC;	/* force an exit from insert-mode */
		v_write(pty, Line, 1);
d910 11
a920 8
		if (line < 0) {
		    line = -line;
		    Line[0] = CONTROL('n');
		} else {
		    Line[0] = CONTROL('p');
		}
		while (--line >= 0)
		    v_write(pty, Line, 1);
d922 2
d938 16
a953 13
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
	TScreen *screen = &(xw->screen);
	CELL cell;

	screen->selection_time = event->xmotion.time;
	switch (eventMode) {
	    /* If not in one of the DEC mouse-reporting modes */
	case LEFTEXTENSION:
	case RIGHTEXTENSION:
	    PointToCELL(screen, event->xmotion.y, event->xmotion.x, &cell);
	    ExtendExtend(screen, &cell);
	    break;
d955 7
a961 9
	    /* If in motion reporting mode, send mouse position to
	       character process as a key sequence \E[M... */
	case NORMAL:
	    /* will get here if send_mouse_pos != MOUSE_OFF */
	    if (screen->send_mouse_pos == BTN_EVENT_MOUSE
		|| screen->send_mouse_pos == ANY_EVENT_MOUSE) {
		(void) SendMousePosition(xw, event);
	    }
	    break;
d963 1
a963 12
    }
}

void
HandleKeyboardSelectExtend(Widget w,
			   XEvent * event GCC_UNUSED,	/* must be XButtonEvent */
			   String * params GCC_UNUSED,
			   Cardinal *num_params GCC_UNUSED)
{
    if (IsXtermWidget(w)) {
	TScreen *screen = &((XtermWidget) w)->screen;
	ExtendExtend(screen, &screen->cursorp);
d968 1
a968 1
do_select_end(XtermWidget xw,
d976 1
a976 1
    TScreen *screen = &xw->screen;
d979 5
a983 1
    xw->screen.selection_time = event->xbutton.time;
d986 1
a986 1
	(void) SendMousePosition(xw, event);
d990 1
a990 1
	EndExtend(xw, event, params, *num_params, use_cursor_loc);
d992 1
a992 1
	if (isClick1_clean(screen, event)
d994 2
a995 2
	    && rowOnCurrentLine(screen, eventRow(screen, event), &ldelta1)) {
	    ReadLineMovePoint(screen, eventColBetween(screen, event), ldelta1);
d997 1
a997 1
	if (isDoubleClick3(screen, event)
d999 4
a1002 4
	    && rowOnCurrentLine(screen, screen->startSel.row, &ldelta1)
	    && rowOnCurrentLine(screen, screen->endSel.row, &ldelta2)) {
	    ReadLineMovePoint(screen, screen->endSel.col, ldelta2);
	    ReadLineDelete(screen, &screen->startSel, &(screen->endSel));
d1015 1
a1015 2
    if (IsXtermWidget(w))
	do_select_end((XtermWidget) w, event, params, num_params, False);
d1024 1
a1024 2
    if (IsXtermWidget(w))
	do_select_end((XtermWidget) w, event, params, num_params, True);
d1034 3
a1036 3
/*
 * Convert a UTF-8 string to Latin-1, replacing non Latin-1 characters by `#'.
 */
a1136 64
#define isSELECT(value) (!strcmp(value, "SELECT"))

static void
UnmapSelections(XtermWidget xw)
{
    TScreen *screen = &(xw->screen);
    Cardinal n;

    if (screen->mappedSelect) {
	for (n = 0; screen->mappedSelect[n] != 0; ++n)
	    free(screen->mappedSelect[n]);
	free(screen->mappedSelect);
	screen->mappedSelect = 0;
    }
}

/*
 * xterm generally uses the primary selection.  Some applications prefer
 * (or are limited to) the clipboard.  Since the translations resource is
 * complicated, users seldom change the way it affects selection.  But it
 * is simple to remap the choice between primary and clipboard before the
 * call to XmuInternStrings().
 */
static String *
MapSelections(XtermWidget xw, String * params, Cardinal num_params)
{
    String *result = params;

    if (num_params > 0) {
	Cardinal j;
	Boolean map = False;

	for (j = 0; j < num_params; ++j) {
	    TRACE(("param[%d]:%s\n", j, params[j]));
	    if (isSELECT(params[j])) {
		map = True;
		break;
	    }
	}
	if (map) {
	    String mapTo = (xw->screen.selectToClipboard
			    ? "CLIPBOARD"
			    : "PRIMARY");

	    UnmapSelections(xw);
	    if ((result = TypeMallocN(String, num_params + 1)) != 0) {
		result[num_params] = 0;
		for (j = 0; j < num_params; ++j) {
		    result[j] = x_strdup((isSELECT(params[j])
					  ? mapTo
					  : params[j]));
		    if (result[j] == 0) {
			UnmapSelections(xw);
			result = 0;
			break;
		    }
		}
		xw->screen.mappedSelect = result;
	    }
	}
    }
    return result;
}

a1176 1
#if OPT_PASTE64
d1178 5
a1182 19
FinishPaste64(TScreen * screen)
{
    TRACE(("FinishPaste64(%d)\n", screen->base64_paste));
    if (screen->base64_paste) {
	screen->base64_paste = 0;
	unparseputc1(screen->base64_final, screen->respond);
    }
}
#endif

#if !OPT_PASTE64
static
#endif
void
xtermGetSelection(Widget w,
		  Time ev_time,
		  String * params,	/* selections in precedence order */
		  Cardinal num_params,
		  Atom * targets)
d1191 9
a1199 2
    TRACE(("xtermGetSelection\n"));
    params = MapSelections((XtermWidget) w, params, num_params);
a1202 1

a1204 1

a1214 1

d1218 2
a1219 8
	else if (num_params > 1) {
	    xtermGetSelection(w, ev_time, params + 1, num_params - 1, NULL);
	}
#if OPT_PASTE64
	else {
	    FinishPaste64(&(((XtermWidget) w)->screen));
	}
#endif
d1269 3
a1271 9
    TRACE(("Getting %s (%ld)\n", name, (long int) type));
    for (cp = line; cp < line + len; cp++) {
	TRACE(("[%d:%lu]", cp + 1 - line, len));
	if (isprint(*cp)) {
	    TRACE(("%c\n", *cp));
	} else {
	    TRACE(("\\x%02x\n", *cp));
	}
    }
a1282 32
#if OPT_PASTE64
/* Return base64 code character given 6-bit number */
static const char base64_code[] = "\
ABCDEFGHIJKLMNOPQRSTUVWXYZ\
abcdefghijklmnopqrstuvwxyz\
0123456789+/";
static void
base64_flush(TScreen * screen)
{
    Char x;
    switch (screen->base64_count) {
    case 0:
	break;
    case 2:
	x = base64_code[screen->base64_accu << 4];
	tty_vwrite(screen->respond, &x, 1);
	break;
    case 4:
	x = base64_code[screen->base64_accu << 2];
	tty_vwrite(screen->respond, &x, 1);
	break;
    }
    if (screen->base64_pad & 3)
	tty_vwrite(screen->respond,
		   (Char *) "===",
		   (unsigned) (4 - (screen->base64_pad & 3)));
    screen->base64_count = 0;
    screen->base64_accu = 0;
    screen->base64_pad = 0;
}
#endif /* OPT_PASTE64 */

a1285 41
#if OPT_PASTE64
    if (screen->base64_paste) {
	/* Send data as base64 */
	Char *p = lag;
	Char buf[64];
	unsigned x = 0;
	while (length--) {
	    switch (screen->base64_count) {
	    case 0:
		buf[x++] = base64_code[*p >> 2];
		screen->base64_accu = (*p & 0x3);
		screen->base64_count = 2;
		++p;
		break;
	    case 2:
		buf[x++] = base64_code[(screen->base64_accu << 4) + (*p >> 4)];
		screen->base64_accu = (*p & 0xF);
		screen->base64_count = 4;
		++p;
		break;
	    case 4:
		buf[x++] = base64_code[(screen->base64_accu << 2) + (*p >> 6)];
		buf[x++] = base64_code[*p & 0x3F];
		screen->base64_accu = 0;
		screen->base64_count = 0;
		++p;
		break;
	    }
	    if (x >= 63) {
		/* Write 63 or 64 characters */
		screen->base64_pad += x;
		tty_vwrite(screen->respond, buf, x);
		x = 0;
	    }
	}
	if (x != 0) {
	    screen->base64_pad += x;
	    tty_vwrite(screen->respond, buf, x);
	}
    } else
#endif /* OPT_PASTE64 */
d1289 1
a1289 1
	    tty_vwrite(screen->respond, (Char *) "\026", 1);	/* Control-V */
d1304 1
a1304 1
    Char *lag, *end;
d1316 6
a1321 16

#if OPT_PASTE64
    if (screen->base64_paste) {
	_qWriteSelectionData(screen, lag, (unsigned) (end - lag));
	base64_flush(screen);
    } else
#endif
    {
	if (!SCREEN_FLAG(screen, paste_literal_nl)) {
	    Char *cp;
	    for (cp = line; cp != end; cp++) {
		if (*cp == '\n') {
		    *cp = '\r';
		    _qWriteSelectionData(screen, lag, (unsigned) (cp - lag + 1));
		    lag = cp + 1;
		}
d1324 3
a1326 4

	if (lag != end) {
	    _qWriteSelectionData(screen, lag, (unsigned) (end - lag));
	}
d1338 1
a1338 1
    Char line[16];
d1340 1
a1340 1
    unsigned length = strlen((char *) in);
d1365 1
a1365 1
		  int *format)
a1436 5
#if OPT_PASTE64
	if (screen->base64_paste) {
	    ;
	} else
#endif
d1438 2
a1439 3
	if (SCREEN_FLAG(screen, paste_brackets)) {
	    _WriteKey(screen, (Char *) "200");
	}
a1444 5
#if OPT_PASTE64
	if (screen->base64_paste) {
	    FinishPaste64(screen);
	} else
#endif
d1446 2
a1447 3
	if (SCREEN_FLAG(screen, paste_brackets)) {
	    _WriteKey(screen, (Char *) "201");
	}
d1461 2
a1462 2
	xtermGetSelection(w, list->time,
			  list->params, list->count, list->targets);
a1463 4
#if OPT_PASTE64
    } else {
	FinishPaste64(screen);
#endif
d1474 7
a1480 2
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
a1481 1
	if (!SendMousePosition(xw, event)) {
d1483 7
a1489 9
	    int ldelta;
	    TScreen *screen = &(xw->screen);
	    if ((event->type == ButtonPress || event->type == ButtonRelease)
	    /* Disable on Shift-mouse, including the application-mouse modes */
		&& !(KeyModifiers & ShiftMask)
		&& (screen->send_mouse_pos == MOUSE_OFF)
		&& SCREEN_FLAG(screen, paste_moves)
		&& rowOnCurrentLine(screen, eventRow(screen, event), &ldelta))
		ReadLineMovePoint(screen, eventColBetween(screen, event), ldelta);
d1492 1
a1492 3
	    xtermGetSelection(w, event->xbutton.time, params, *num_params, NULL);
	}
    }
d1496 1
a1496 1
EvalSelectUnit(TScreen * screen, Time buttonDownTime, SelectUnit defaultUnit)
a1497 1
    SelectUnit result;
d1500 6
a1505 10
    if (screen->lastButtonUpTime == (Time) 0) {
	/* first time and once in a blue moon */
	delta = screen->multiClickTime + 1;
    } else if (buttonDownTime > screen->lastButtonUpTime) {
	/* most of the time */
	delta = buttonDownTime - screen->lastButtonUpTime;
    } else {
	/* time has rolled over since lastButtonUpTime */
	delta = (((Time) ~ 0) - screen->lastButtonUpTime) + buttonDownTime;
    }
d1507 3
a1509 3
    if (delta > screen->multiClickTime) {
	screen->numberOfClicks = 1;
	result = defaultUnit;
d1511 2
a1512 2
	result = screen->selectMap[screen->numberOfClicks % screen->maxClicks];
	screen->numberOfClicks += 1;
a1513 2
    TRACE(("EvalSelectUnit(%d) = %d\n", screen->numberOfClicks, result));
    return result;
d1517 1
a1517 1
do_select_start(XtermWidget xw,
d1519 2
a1520 1
		CELL * cell)
d1522 1
a1522 3
    TScreen *screen = &(xw->screen);

    if (SendMousePosition(xw, event))
d1524 2
a1525 2
    screen->selectUnit = EvalSelectUnit(screen, event->xbutton.time, Select_CHAR);
    screen->replyToEmacs = False;
d1531 1
a1531 1
    StartSelect(screen, cell);
d1541 10
a1550 8
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
	TScreen *screen = &(xw->screen);
	CELL cell;

	screen->firstValidRow = 0;
	screen->lastValidRow = screen->max_row;
	PointToCELL(screen, event->xbutton.y, event->xbutton.x, &cell);
d1553 1
a1553 1
	ExtendingSelection = 0;
d1556 1
a1556 2
	do_select_start(xw, event, &cell);
    }
d1566 7
a1572 5
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
	TScreen *screen = &(xw->screen);
	do_select_start(xw, event, &screen->cursorp);
    }
d1576 1
a1576 1
TrackDown(TScreen * screen, XButtonEvent * event)
d1578 1
a1578 1
    CELL cell;
d1580 5
a1584 5
    screen->selectUnit = EvalSelectUnit(screen, event->time, Select_CHAR);
    if (screen->numberOfClicks > 1) {
	PointToCELL(screen, event->y, event->x, &cell);
	screen->replyToEmacs = True;
	StartSelect(screen, &cell);
d1586 2
a1587 2
	waitingForTrackInfo = True;
	EditorButton(screen, (XButtonEvent *) event);
d1594 1
a1594 1
			    x = screen->max_row
d1597 1
a1597 5
TrackMouse(TScreen * screen,
	   int func,
	   CELL * start,
	   int firstrow,
	   int lastrow)
d1599 1
a1599 4
    if (waitingForTrackInfo) {	/* if Timed, ignore */
	waitingForTrackInfo = False;
	if (func != 0) {
	    CELL first = *start;
d1601 2
a1602 8
	    boundsCheck(first.row);
	    boundsCheck(firstrow);
	    boundsCheck(lastrow);
	    screen->firstValidRow = firstrow;
	    screen->lastValidRow = lastrow;
	    screen->replyToEmacs = True;
	    StartSelect(screen, &first);
	}
d1604 10
d1617 1
a1617 1
StartSelect(TScreen * screen, const CELL * cell)
d1619 3
a1621 1
    TRACE(("StartSelect row=%d, col=%d\n", cell->row, cell->col));
d1624 1
a1624 1
    if (screen->numberOfClicks == 1) {
d1626 3
a1628 1
	screen->rawPos = *cell;
d1630 6
a1635 4
    /* else use old values in rawPos */
    screen->saveStartR = screen->startExt = screen->rawPos;
    screen->saveEndR = screen->endExt = screen->rawPos;
    if (Coordinate(screen, cell) < Coordinate(screen, &(screen->rawPos))) {
d1637 2
a1638 1
	screen->startExt = *cell;
d1641 2
a1642 1
	screen->endExt = *cell;
d1644 1
a1644 1
    ComputeSelect(screen, &(screen->startExt), &(screen->endExt), False);
d1648 1
a1648 1
EndExtend(XtermWidget xw,
d1654 1
a1654 1
    CELL cell;
d1656 1
a1656 1
    TScreen *screen = &xw->screen;
d1660 2
a1661 1
	cell = screen->cursorp;
d1663 1
a1663 1
	PointToCELL(screen, event->xbutton.y, event->xbutton.x, &cell);
d1665 4
a1668 4
    ExtendExtend(screen, &cell);
    screen->lastButtonUpTime = event->xbutton.time;
    if (!isSameCELL(&(screen->startSel), &(screen->endSel))) {
	if (screen->replyToEmacs) {
d1676 2
a1677 2
	    if (isSameCELL(&(screen->rawPos), &(screen->startSel))
		&& isSameCELL(&cell, &(screen->endSel))) {
d1680 2
a1681 2
		line[count++] = ' ' + screen->endSel.col + 1;
		line[count++] = ' ' + screen->endSel.row + 1;
d1685 6
a1690 6
		line[count++] = ' ' + screen->startSel.col + 1;
		line[count++] = ' ' + screen->startSel.row + 1;
		line[count++] = ' ' + screen->endSel.col + 1;
		line[count++] = ' ' + screen->endSel.row + 1;
		line[count++] = ' ' + cell.col + 1;
		line[count++] = ' ' + cell.row + 1;
d1693 1
a1693 1
	    TrackText(screen, &zeroCELL, &zeroCELL);
d1696 1
a1696 1
    SelectSet(xw, event, params, num_params);
d1706 1
a1706 3
    if (IsXtermWidget(w)) {
	SelectSet((XtermWidget) w, event, params, *num_params);
    }
d1711 1
a1711 1
SelectSet(XtermWidget xw,
a1715 2
    TScreen *screen = &(xw->screen);

d1718 3
a1720 2
    if (!isSameCELL(&(screen->startSel), &(screen->endSel))) {
	SaltTextAway(xw, &(screen->startSel), &(screen->endSel), params, num_params);
d1722 1
a1722 1
	DisownSelection(xw);
d1730 1
a1730 1
do_start_extend(XtermWidget xw,
d1736 2
a1737 3
    TScreen *screen = &(xw->screen);
    int coord;
    CELL cell;
d1739 1
a1739 1
    if (!IsXtermWidget(xw))
d1742 2
a1743 1
    if (SendMousePosition(xw, event))
d1745 2
a1746 3

    screen->firstValidRow = 0;
    screen->lastValidRow = screen->max_row;
d1752 2
a1753 2
	screen->selectUnit = EvalSelectUnit(screen, event->xbutton.time, screen->selectUnit);
    screen->replyToEmacs = False;
d1756 1
a1756 1
    CheckSecondPress3(screen, event);
d1759 1
a1759 1
    if (screen->numberOfClicks == 1
d1764 4
a1767 2
	screen->saveStartR = screen->startExt = screen->startRaw;
	screen->saveEndR = screen->endExt = screen->endRaw;
d1770 5
a1774 2
	screen->startExt = screen->startRaw = screen->saveStartR;
	screen->endExt = screen->endRaw = screen->saveEndR;
d1777 2
a1778 1
	cell = screen->cursorp;
d1780 1
a1780 1
	PointToCELL(screen, event->xbutton.y, event->xbutton.x, &cell);
d1782 1
a1782 1
    coord = Coordinate(screen, &cell);
d1784 3
a1786 3
    if (Abs(coord - Coordinate(screen, &(screen->startSel)))
	< Abs(coord - Coordinate(screen, &(screen->endSel)))
	|| coord < Coordinate(screen, &(screen->startSel))) {
d1789 2
a1790 1
	screen->startExt = cell;
d1794 2
a1795 1
	screen->endExt = cell;
d1797 1
a1797 1
    ComputeSelect(screen, &(screen->startExt), &(screen->endExt), True);
d1800 1
a1800 1
    if (!isSameCELL(&(screen->startSel), &(screen->endSel)))
d1806 1
a1806 1
ExtendExtend(TScreen * screen, const CELL * cell)
d1808 1
a1808 1
    int coord = Coordinate(screen, cell);
d1810 1
a1810 1
    TRACE(("ExtendExtend row=%d, col=%d\n", cell->row, cell->col));
d1812 1
a1812 2
	&& ((coord + (screen->selectUnit != Select_CHAR))
	    > Coordinate(screen, &(screen->endSel)))) {
d1815 2
a1816 1
	screen->startExt = screen->saveStartR;
d1818 1
a1818 1
	       && coord < Coordinate(screen, &(screen->startSel))) {
d1821 2
a1822 1
	screen->endExt = screen->saveEndR;
d1825 2
a1826 1
	screen->startExt = *cell;
d1828 2
a1829 1
	screen->endExt = *cell;
d1831 1
a1831 1
    ComputeSelect(screen, &(screen->startExt), &(screen->endExt), False);
d1834 1
a1834 1
    if (!isSameCELL(&(screen->startSel), &(screen->endSel)))
d1845 1
a1845 2
    if (IsXtermWidget(w))
	do_start_extend((XtermWidget) w, event, params, num_params, False);
d1854 1
a1854 2
    if (IsXtermWidget(w))
	do_start_extend((XtermWidget) w, event, params, num_params, True);
d1860 2
a1861 2
    int minrow = INX2ROW(screen, -screen->savedlines);
    int maxrow = INX2ROW(screen, screen->max_row);
d1864 5
a1868 5
#define scroll_update_one(cell) \
	(cell)->row += amount; \
	if ((cell)->row < minrow) { \
	    (cell)->row = minrow; \
	    (cell)->col = 0; \
d1870 3
a1872 3
	if ((cell)->row > maxrow) { \
	    (cell)->row = maxrow; \
	    (cell)->col = maxcol; \
d1875 4
a1878 4
    scroll_update_one(&(screen->startRaw));
    scroll_update_one(&(screen->endRaw));
    scroll_update_one(&(screen->startSel));
    scroll_update_one(&(screen->endSel));
d1880 1
a1880 1
    scroll_update_one(&(screen->rawPos));
d1892 1
a1892 1
	adjust = ROW2INX(screen, screen->startH.row);
d1896 1
a1896 1
	    scroll_update_one(&screen->startH);
d1898 1
a1898 1
	adjust = ROW2INX(screen, screen->endH.row);
d1902 1
a1902 1
	    scroll_update_one(&screen->endH);
d1906 2
a1907 2
    screen->startHCoord = Coordinate(screen, &screen->startH);
    screen->endHCoord = Coordinate(screen, &screen->endH);
d1917 21
a1937 21
    if (screen->startRaw.row > rows)
	screen->startRaw.row = rows;
    if (screen->startSel.row > rows)
	screen->startSel.row = rows;
    if (screen->endRaw.row > rows)
	screen->endRaw.row = rows;
    if (screen->endSel.row > rows)
	screen->endSel.row = rows;
    if (screen->rawPos.row > rows)
	screen->rawPos.row = rows;

    if (screen->startRaw.col > cols)
	screen->startRaw.col = cols;
    if (screen->startSel.col > cols)
	screen->startSel.col = cols;
    if (screen->endRaw.col > cols)
	screen->endRaw.col = cols;
    if (screen->endSel.col > cols)
	screen->endSel.col = cols;
    if (screen->rawPos.col > cols)
	screen->rawPos.col = cols;
d1951 4
a1954 4
PointToCELL(TScreen * screen,
	    int y,
	    int x,
	    CELL * cell)
d1960 13
a1972 10
    cell->row = (y - screen->border) / FontHeight(screen);
    if (cell->row < screen->firstValidRow)
	cell->row = screen->firstValidRow;
    else if (cell->row > screen->lastValidRow)
	cell->row = screen->lastValidRow;
    cell->col = (x - OriginX(screen)) / FontWidth(screen);
    if (cell->col < 0)
	cell->col = 0;
    else if (cell->col > MaxCols(screen)) {
	cell->col = MaxCols(screen);
d1979 4
a1982 4
    if (cell->col > 0
	&& isWideCell(cell->row, cell->col - 1)
	&& (XTERM_CELL(cell->row, cell->col) == HIDDEN_CHAR)) {
	cell->col -= 1;
d1985 2
a1988 3
/*
 * Find the last column at which text was drawn on the given row.
 */
d1990 1
a1990 1
LastTextCol(TScreen * screen, int row)
d1992 1
a1992 1
    int inx = ROW2INX(screen, row);
d1996 1
a1996 1
    if (inx + screen->savedlines >= 0) {
d1998 1
a1998 1
	     ch = SCRN_BUF_ATTRS(screen, inx) + i;
d2002 1
a2002 1
	if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, inx)[0])) {
d2110 1
a2110 1
class_of(TScreen * screen, CELL * cell)
a2111 1
    CELL temp = *cell;
a2112 1

d2114 2
a2115 2
    if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, ROW2INX(screen, temp.row))[0])) {
	temp.col /= 2;
d2118 1
a2118 2

    value = XTERM_CELL(temp.row, temp.col);
d2124 3
a2126 3
#define ClassSelects(screen, cell, cclass) \
	 (class_of(screen, cell) == cclass \
	 || XTERM_CELL((cell)->row, (cell)->col) == HIDDEN_CHAR)
d2128 3
a2130 3
#define class_of(screen, cell) charClass[XTERM_CELL((cell)->row, (cell)->col)]
#define ClassSelects(screen, cell, cclass) \
	 (class_of(screen, (cell)) == cclass)
d2134 1
a2134 263
 * If the given column is past the end of text on the given row, bump to the
 * beginning of the next line.
 */
static Boolean
okPosition(TScreen * screen,
	   CELL * cell)
{
    if (cell->col > (LastTextCol(screen, cell->row) + 1)) {
	cell->col = 0;
	cell->row += 1;
	return False;
    }
    return True;
}

static void
trimLastLine(TScreen * screen, CELL * last)
{
    if (screen->cutNewline) {
	last->col = 0;
	++last->row;
    } else {
	last->col = LastTextCol(screen, last->row) + 1;
    }
}

#if OPT_SELECT_REGEX
/*
 * Returns the first row of a wrapped line.
 */
static int
firstRowOfLine(TScreen * screen, int row, Bool visible)
{
    int limit = visible ? 0 : -screen->savedlines;

    while (row > limit &&
	   ScrnTstWrapped(screen, row - 1))
	--row;
    return row;
}

/*
 * Returns the last row of a wrapped line.
 */
static int
lastRowOfLine(TScreen * screen, int row)
{
    while (row < screen->max_row &&
	   ScrnTstWrapped(screen, row))
	++row;
    return row;
}

/*
 * Returns the number of cells on the range of rows.
 */
static unsigned
lengthOfLines(TScreen * screen, int firstRow, int lastRow)
{
    unsigned length = 0;
    int n;

    for (n = firstRow; n <= lastRow; ++n) {
	int value = LastTextCol(screen, n);
	if (value >= 0)
	    length += (value + 1);
    }
    return length;
}

/*
 * Make a copy of the wrapped-line which corresponds to the given row as a
 * string of bytes.  Construct an index for the columns from the beginning of
 * the line.
 */
static char *
make_indexed_text(TScreen * screen, int row, unsigned length, int *indexed)
{
    Char *result = 0;
    unsigned need = (length + 1);

    /*
     * Get a quick upper bound to the number of bytes needed, if the whole
     * string were UTF-8.
     */
    if_OPT_WIDE_CHARS(screen, {
	need *= (MAX_PTRS * 6);
    });

    if ((result = TypeCallocN(Char, need + 1)) != 0) {
	unsigned used = 0;
	Char *last = result;

	do {
	    int col = 0;
	    int limit = LastTextCol(screen, row);

	    while (col <= limit) {
		Char *next = last;
		unsigned data = XTERM_CELL(row, col);

		/* some internal points may not be drawn */
		if (data == 0)
		    data = ' ';
#if OPT_WIDE_CHARS
		next = convertToUTF8(last, data);
#else
		*next++ = CharOf(data);
#endif

		if_OPT_WIDE_CHARS(screen, {
		    if ((data = XTERM_CELL_C1(row, col)) != 0)
			next = convertToUTF8(next, data);
		    if ((data = XTERM_CELL_C2(row, col)) != 0)
			next = convertToUTF8(next, data);
		});

		indexed[used] = last - result;
		*next = 0;
		/* TRACE(("index[%d.%d] %d:%s\n", row, used, indexed[used], last)); */
		last = next;
		++used;
		++col;
		indexed[used] = next - result;
	    }
	} while (used < length &&
		 ScrnTstWrapped(screen, row) &&
		 ++row < screen->max_row);
    }
    /* TRACE(("result:%s\n", result)); */
    return (char *) result;
}

/*
 * Find the column given an offset into the character string by using the
 * index constructed in make_indexed_text().
 */
static int
indexToCol(int *indexed, int len, int off)
{
    int col = 0;
    while (indexed[col] < len) {
	if (indexed[col] >= off)
	    break;
	++col;
    }
    return col;
}

/*
 * Given a row number, and a column offset from that (which may be wrapped),
 * set the cell to the actual row/column values.
 */
static void
columnToCell(TScreen * screen, int row, int col, CELL * cell)
{
    while (row < screen->max_row) {
	int last = LastTextCol(screen, row);

	/* TRACE(("last(%d) = %d, have %d\n", row, last, col)); */
	if (col <= last) {
	    break;
	}
	col -= (last + 1);
	++row;
    }
    if (col < 0)
	col = 0;
    cell->row = row;
    cell->col = col;
}

/*
 * Given a cell, find the corresponding column offset.
 */
static int
cellToColumn(TScreen * screen, CELL * cell)
{
    int col = cell->col;
    int row = firstRowOfLine(screen, cell->row, False);
    while (row < cell->row) {
	col += LastTextCol(screen, row++);
    }
    return col;
}

static void
do_select_regex(TScreen * screen, CELL * startc, CELL * endc)
{
    char *expr = screen->selectExpr[screen->numberOfClicks - 1];
    regex_t preg;
    regmatch_t match;
    char *search;
    int *indexed;

    TRACE(("Select_REGEX:%s\n", NonNull(expr)));
    if (okPosition(screen, startc) && expr != 0) {
	if (regcomp(&preg, expr, REG_EXTENDED) == 0) {
	    int firstRow = firstRowOfLine(screen, startc->row, True);
	    int lastRow = lastRowOfLine(screen, firstRow);
	    unsigned size = lengthOfLines(screen, firstRow, lastRow);
	    int actual = cellToColumn(screen, startc);

	    TRACE(("regcomp ok rows %d..%d bytes %d\n",
		   firstRow, lastRow, size));

	    if ((indexed = TypeCallocN(int, size + 1)) != 0) {
		if ((search = make_indexed_text(screen,
						firstRow,
						size,
						indexed)) != 0) {
		    int len = strlen(search);
		    int col;
		    int best_col = -1;
		    int best_len = -1;

		    for (col = 0; indexed[col] < len; ++col) {
			if (regexec(&preg,
				    search + indexed[col],
				    1, &match, 0) == 0) {
			    int start_inx = match.rm_so + indexed[col];
			    int finis_inx = match.rm_eo + indexed[col];
			    int start_col = indexToCol(indexed, len, start_inx);
			    int finis_col = indexToCol(indexed, len, finis_inx);

			    if (start_col <= actual &&
				actual < finis_col) {
				int test = finis_col - start_col;
				if (best_len < test) {
				    best_len = test;
				    best_col = start_col;
				    TRACE(("match column %d len %d\n",
					   best_col,
					   best_len));
				}
			    }
			}
		    }
		    if (best_col >= 0) {
			columnToCell(screen, firstRow, best_col, startc);
			columnToCell(screen, firstRow, best_col + best_len, endc);
			TRACE(("search::%s\n", search));
			TRACE(("indexed:%d..%d -> %d..%d\n",
			       best_col, best_col + best_len,
			       indexed[best_col],
			       indexed[best_col + best_len]));
			TRACE(("matched:%.*s\n",
			       indexed[best_col + best_len] + 1 -
			       indexed[best_col],
			       search + indexed[best_col]));
		    }
		    free(search);
		}
		free(indexed);
	    }
	    regfree(&preg);
	}
    }
}
#endif /* OPT_SELECT_REGEX */

/*
 * sets startSel endSel
d2138 4
a2141 3
ComputeSelect(TScreen * screen,
	      CELL * startc,
	      CELL * endc,
d2144 1
a2146 2
    CELL first = *startc;
    CELL last = *endc;
d2149 1
a2149 3
	   first.row, first.col,
	   last.row, last.col,
	   extend ? "" : "no"));
d2152 13
a2164 13
    if (first.col > 1
	&& isWideCell(first.row, first.col - 1)
	&& XTERM_CELL(first.row, first.col - 0) == HIDDEN_CHAR) {
	fprintf(stderr, "Adjusting start. Changing downwards from %i.\n", first.col);
	first.col -= 1;
	if (last.col == (first.col + 1))
	    last.col--;
    }

    if (last.col > 1
	&& isWideCell(last.row, last.col - 1)
	&& XTERM_CELL(last.row, last.col) == HIDDEN_CHAR) {
	last.col += 1;
d2168 5
a2172 3
    if (Coordinate(screen, &first) <= Coordinate(screen, &last)) {
	screen->startSel = screen->startRaw = first;
	screen->endSel = screen->endRaw = last;
d2174 23
a2196 14
	screen->startSel = screen->startRaw = last;
	screen->endSel = screen->endRaw = first;
    }

    switch (screen->selectUnit) {
    case Select_CHAR:
	(void) okPosition(screen, &(screen->startSel));
	(void) okPosition(screen, &(screen->endSel));
	break;

    case Select_WORD:
	TRACE(("Select_WORD\n"));
	if (okPosition(screen, &(screen->startSel))) {
	    cclass = class_of(screen, &(screen->startSel));
d2198 5
a2202 6
		--screen->startSel.col;
		if (screen->startSel.row > 0
		    && screen->startSel.col < 0
		    && ScrnTstWrapped(screen, screen->startSel.row - 1)) {
		    --screen->startSel.row;
		    screen->startSel.col = LastTextCol(screen, screen->startSel.row);
d2204 3
a2206 3
	    } while (screen->startSel.col >= 0
		     && ClassSelects(screen, &(screen->startSel), cclass));
	    ++screen->startSel.col;
d2208 1
d2210 2
a2211 4
	if (screen->startSel.col
	    && XTERM_CELL(screen->startSel.row,
			  screen->startSel.col) == HIDDEN_CHAR)
	    screen->startSel.col++;
d2214 6
a2219 3
	if (okPosition(screen, &(screen->endSel))) {
	    length = LastTextCol(screen, screen->endSel.row);
	    cclass = class_of(screen, &(screen->endSel));
d2221 6
a2226 6
		++screen->endSel.col;
		if (screen->endSel.col > length
		    && ScrnTstWrapped(screen, screen->endSel.row)) {
		    screen->endSel.col = 0;
		    ++screen->endSel.row;
		    length = LastTextCol(screen, screen->endSel.row);
d2228 9
a2236 9
	    } while (screen->endSel.col <= length
		     && ClassSelects(screen, &(screen->endSel), cclass));
	    /* Word-select selects if pointing to any char in "word",
	     * especially note that it includes the last character in a word.
	     * So we do no --endSel.col and do special eol handling.
	     */
	    if (screen->endSel.col > length + 1) {
		screen->endSel.col = 0;
		++screen->endSel.row;
d2239 1
d2241 2
a2242 4
	if (screen->endSel.col
	    && XTERM_CELL(screen->endSel.row,
			  screen->endSel.col) == HIDDEN_CHAR)
	    screen->endSel.col++;
d2245 2
a2246 1
	screen->saveStartW = screen->startSel;
d2248 9
a2256 12

    case Select_LINE:
	TRACE(("Select_LINE\n"));
	while (ScrnTstWrapped(screen, screen->endSel.row)) {
	    ++screen->endSel.row;
	}
	if (screen->cutToBeginningOfLine
	    || screen->startSel.row < screen->saveStartW.row) {
	    screen->startSel.col = 0;
	    while (screen->startSel.row > 0
		   && ScrnTstWrapped(screen, screen->startSel.row - 1)) {
		--screen->startSel.row;
d2259 6
a2264 7
	    if ((first.row < screen->saveStartW.row)
		|| (isSameRow(&first, &(screen->saveStartW))
		    && first.col < screen->saveStartW.col)) {
		screen->startSel.col = 0;
		while (screen->startSel.row > 0
		       && ScrnTstWrapped(screen, screen->startSel.row - 1)) {
		    --screen->startSel.row;
d2267 2
a2268 1
		screen->startSel = screen->saveStartW;
d2271 5
a2275 20
	trimLastLine(screen, &(screen->endSel));
	break;

    case Select_GROUP:		/* paragraph */
	TRACE(("Select_GROUP\n"));
	if (okPosition(screen, &(screen->startSel))) {
	    /* scan backward for beginning of group */
	    while (screen->startSel.row > 0 &&
		   (LastTextCol(screen, screen->startSel.row - 1) > 0 ||
		    ScrnTstWrapped(screen, screen->startSel.row - 1))) {
		--screen->startSel.row;
	    }
	    screen->startSel.col = 0;
	    /* scan forward for end of group */
	    while (screen->endSel.row < screen->max_row &&
		   (LastTextCol(screen, screen->endSel.row + 1) > 0 ||
		    ScrnTstWrapped(screen, screen->endSel.row))) {
		++screen->endSel.row;
	    }
	    trimLastLine(screen, &(screen->endSel));
a2277 25

    case Select_PAGE:		/* everything one can see */
	TRACE(("Select_PAGE\n"));
	screen->startSel.row = 0;
	screen->startSel.col = 0;
	screen->endSel.row = screen->max_row + 1;
	screen->endSel.col = 0;
	break;

    case Select_ALL:		/* counts scrollback if in normal screen */
	TRACE(("Select_ALL\n"));
	screen->startSel.row = -screen->savedlines;
	screen->startSel.col = 0;
	screen->endSel.row = screen->max_row + 1;
	screen->endSel.col = 0;
	break;

#if OPT_SELECT_REGEX
    case Select_REGEX:
	do_select_regex(screen, &(screen->startSel), &(screen->endSel));
	break;
#endif

    case NSELECTUNITS:		/* always ignore */
	return;
d2283 1
a2283 1
    TrackText(screen, &(screen->startSel), &(screen->endSel));
d2287 6
a2292 5
/* Guaranteed (first.row, first.col) <= (last.row, last.col) */
static void
TrackText(TScreen * screen,
	  const CELL * firstp,
	  const CELL * lastp)
d2295 19
a2313 16
    CELL old_start, old_end;
    CELL first = *firstp;
    CELL last = *lastp;

    TRACE(("TrackText(first=%d,%d, last=%d,%d)\n",
	   first.row, first.col, last.row, last.col));

    old_start = screen->startH;
    old_end = screen->endH;
    if (isSameCELL(&first, &old_start) &&
	isSameCELL(&last, &old_end))
	return;
    screen->startH = first;
    screen->endH = last;
    from = Coordinate(screen, &screen->startH);
    to = Coordinate(screen, &screen->endH);
d2316 2
a2317 2
	ReHiliteText(screen, &old_start, &old_end);
	ReHiliteText(screen, &first, &last);
d2321 1
a2321 1
	    ReHiliteText(screen, &first, &old_start);
d2324 1
a2324 1
	    ReHiliteText(screen, &old_start, &first);
d2328 1
a2328 1
	    ReHiliteText(screen, &old_end, &last);
d2331 1
a2331 1
	    ReHiliteText(screen, &last, &old_end);
a2337 1
/* Guaranteed that (first->row, first->col) <= (last->row, last->col) */
d2339 5
a2343 3
ReHiliteText(TScreen * screen,
	     CELL * firstp,
	     CELL * lastp)
d2345 1
a2346 2
    CELL first = *firstp;
    CELL last = *lastp;
d2348 1
a2348 2
    TRACE(("ReHiliteText from %d.%d to %d.%d\n",
	   first.row, first.col, last.row, last.col));
d2350 10
a2359 10
    if (first.row < 0)
	first.row = first.col = 0;
    else if (first.row > screen->max_row)
	return;			/* nothing to do, since last.row >= first.row */

    if (last.row < 0)
	return;			/* nothing to do, since first.row <= last.row */
    else if (last.row > screen->max_row) {
	last.row = screen->max_row;
	last.col = MaxCols(screen);
d2361 1
a2361 1
    if (isSameCELL(&first, &last))
d2364 3
a2366 3
    if (!isSameRow(&first, &last)) {	/* do multiple rows */
	if ((i = screen->max_col - first.col + 1) > 0) {	/* first row */
	    ScrnRefresh(screen, first.row, first.col, 1, i, True);
d2368 2
a2369 2
	if ((i = last.row - first.row - 1) > 0) {	/* middle rows */
	    ScrnRefresh(screen, first.row + 1, 0, i, MaxCols(screen), True);
d2371 2
a2372 2
	if (last.col > 0 && last.row <= screen->max_row) {	/* last row */
	    ScrnRefresh(screen, last.row, 0, 1, last.col, True);
d2375 1
a2375 1
	ScrnRefresh(screen, first.row, first.col, 1, last.col - first.col, True);
a2378 4
/*
 * Guaranteed that (cellc->row, cellc->col) <= (cell->row, cell->col), and that both points are valid
 * (may have cell->row = screen->max_row+1, cell->col = 0).
 */
d2380 1
a2380 3
SaltTextAway(XtermWidget xw,
	     CELL * cellc,
	     CELL * cell,
d2383 2
d2386 1
a2386 1
    TScreen *screen = &(xw->screen);
a2390 2
    CELL first = *cellc;
    CELL last = *cell;
d2392 4
a2395 4
    if (isSameRow(&first, &last) && first.col > last.col) {
	int tmp = first.col;
	first.col = last.col;
	last.col = tmp;
d2398 1
a2398 1
    --last.col;
d2401 2
a2402 2
    if (isSameRow(&last, &first)) {
	j = Length(screen, first.row, first.col, last.col);
d2404 2
a2405 2
	j += Length(screen, first.row, first.col, screen->max_col) + 1;
	for (i = first.row + 1; i < last.row; i++)
d2407 2
a2408 2
	if (last.col >= 0)
	    j += Length(screen, last.row, 0, last.col);
d2434 2
a2435 2
    if (isSameRow(&last, &first)) {
	lp = SaveText(screen, last.row, first.col, last.col, lp, &eol);
d2437 1
a2437 1
	lp = SaveText(screen, first.row, first.col, screen->max_col, lp, &eol);
d2440 1
a2440 1
	for (i = first.row + 1; i < last.row; i++) {
d2445 2
a2446 2
	if (last.col >= 0)
	    lp = SaveText(screen, last.row, 0, last.col, lp, &eol);
d2452 1
a2452 9
    _OwnSelection(xw, params, num_params);
}

#if OPT_PASTE64
void
ClearSelectionBuffer(TScreen * screen)
{
    screen->selection_length = 0;
    screen->base64_count = 0;
a2454 88
static void
AppendStrToSelectionBuffer(TScreen * screen, Char * text, unsigned len)
{
    if (len != 0) {
	int j = screen->selection_length + len;		/* New length */
	int k = j + (j >> 2) + 80;	/* New size if we grow buffer: grow by ~50% */
	if (j + 1 >= screen->selection_size) {
	    if (!screen->selection_length) {
		/* New buffer */
		Char *line;
		if ((line = (Char *) malloc((unsigned) k)) == 0)
		    SysError(ERROR_BMALLOC2);
		XtFree((char *) screen->selection_data);
		screen->selection_data = line;
	    } else {
		/* Realloc buffer */
		screen->selection_data = (Char *)
		    realloc(screen->selection_data,
			    (unsigned) k);
		if (screen->selection_data == 0)
		    SysError(ERROR_BMALLOC2);
	    }
	    screen->selection_size = k;
	}
	memcpy(screen->selection_data + screen->selection_length, text, len);
	screen->selection_length += len;
	screen->selection_data[screen->selection_length] = 0;
    }
}

void
AppendToSelectionBuffer(TScreen * screen, unsigned c)
{
    int six;
    Char ch;

    /* Decode base64 character */
    if (c >= 'A' && c <= 'Z')
	six = c - 'A';
    else if (c >= 'a' && c <= 'z')
	six = c - 'a' + 26;
    else if (c >= '0' && c <= '9')
	six = c - '0' + 52;
    else if (c == '+')
	six = 62;
    else if (c == '/')
	six = 63;
    else
	return;

    /* Accumulate bytes */
    switch (screen->base64_count) {
    case 0:
	screen->base64_accu = six;
	screen->base64_count = 6;
	break;

    case 2:
	ch = (screen->base64_accu << 6) + six;
	screen->base64_count = 0;
	AppendStrToSelectionBuffer(screen, &ch, 1);
	break;

    case 4:
	ch = (screen->base64_accu << 4) + (six >> 2);
	screen->base64_accu = (six & 0x3);
	screen->base64_count = 2;
	AppendStrToSelectionBuffer(screen, &ch, 1);
	break;

    case 6:
	ch = (screen->base64_accu << 2) + (six >> 4);
	screen->base64_accu = (six & 0xF);
	screen->base64_count = 4;
	AppendStrToSelectionBuffer(screen, &ch, 1);
	break;
    }
}

void
CompleteSelection(XtermWidget xw, char **args, Cardinal len)
{
    xw->screen.base64_count = 0;
    xw->screen.base64_accu = 0;
    _OwnSelection(xw, args, len);
}
#endif /* OPT_PASTE64 */

d2457 2
a2458 4
			Atom * type,
			XtPointer *value,
			unsigned long *length,
			int *format,
d2465 18
a2482 16
    if (IsXtermWidget(w)) {
	Display *d = XtDisplay(w);
	TScreen *screen = &((XtermWidget) w)->screen;
	XTextProperty textprop;

	if (conversion_function(d, (char **) &screen->selection_data, 1,
				conversion_style,
				&textprop) >= Success) {
	    *value = (XtPointer) textprop.value;
	    *length = textprop.nitems;
	    *type = textprop.encoding;
	    *format = textprop.format;
	    return True;
	}
    }
    return False;
a2510 2

	TRACE(("ConvertSelection XA_TARGETS(d)\n"));
a2540 1
	TRACE(("ConvertSelection XA_STRING - wide\n"));
a2546 1
	TRACE(("ConvertSelection XA_UTF8_STRING(d) - wide\n"));
a2552 1
	TRACE(("ConvertSelection XA_TEXT(d) - wide\n"));
a2558 1
	TRACE(("ConvertSelection XA_COMPOUND_TEXT(d) - wide\n"));
a2573 1
	TRACE(("ConvertSelection XA_STRING\n"));
a2579 1
	TRACE(("ConvertSelection XA_TEXT(d)\n"));
a2585 1
	TRACE(("ConvertSelection XA_COMPOUND_TEXT(d)\n"));
a2593 1
	TRACE(("ConvertSelection XA_UTF8_STRING(d)\n"));
a2601 1
	TRACE(("ConvertSelection XA_LIST_LENGTH(d)\n"));
a2613 1
	TRACE(("ConvertSelection XA_LENGTH(d)\n"));
a2629 1
	TRACE(("ConvertSelection XmuConvertStandardSelection\n"));
d2671 1
a2671 1
	TrackText(screen, &zeroCELL, &zeroCELL);
d2684 1
a2684 1
_OwnSelection(XtermWidget xw,
d2688 1
a2688 2
    TScreen *screen = &(xw->screen);
    Atom *atoms = screen->selection_atoms;
d2692 1
a2692 1
    if (screen->selection_length < 0)
d2695 1
a2695 4
    TRACE(("_OwnSelection\n"));
    selections = MapSelections(xw, selections, count);

    if (count > screen->sel_atoms_size) {
d2698 2
a2699 2
	screen->selection_atoms = atoms;
	screen->sel_atoms_size = count;
d2701 1
a2701 1
    XmuInternStrings(XtDisplay((Widget) xw), selections, count, atoms);
d2705 2
a2706 2
	    if (screen->selection_length >
		4 * XMaxRequestSize(XtDisplay((Widget) xw)) - 32) {
d2709 1
a2709 1
			xterm_name, screen->selection_length, cutbuffer);
d2716 3
a2718 3
		unsigned long length = screen->selection_length;
		Char *data = screen->selection_data;
		if_OPT_WIDE_CHARS((screen), {
d2722 1
a2722 1
		XStoreBuffer(XtDisplay((Widget) xw),
d2727 1
a2727 1
	} else if (!screen->replyToEmacs) {
d2729 2
a2730 2
		XtOwnSelection((Widget) xw, atoms[i],
			       screen->selection_time,
d2734 2
a2735 2
    if (!screen->replyToEmacs)
	screen->selection_count = count;
d2737 1
a2737 1
	TrackText(screen, &zeroCELL, &zeroCELL);
d2744 2
a2745 2
    screen->startH = zeroCELL;
    screen->endH = zeroCELL;
d2749 1
a2749 1
DisownSelection(XtermWidget xw)
d2751 1
a2751 1
    TScreen *screen = &(xw->screen);
d2758 4
a2761 4
	   screen->startH.row,
	   screen->startH.col,
	   screen->endH.row,
	   screen->endH.col));
d2766 1
a2766 1
	    XtDisownSelection((Widget) xw, atoms[i],
d2776 4
a2779 2
	CELL first = screen->startH;
	CELL last = screen->endH;
d2782 1
a2782 1
	ReHiliteText(screen, &first, &last);
d2796 1
a2796 1
    int lastcol = LastTextCol(screen, row);
d2823 1
a2823 1
    if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, ROW2INX(screen, row))[0])) {
d2832 1
a2832 1
	if (screen->utf8_mode != uFalse) {
d2852 1
a2852 1
	if (screen->utf8_mode != uFalse) {
a2887 12
/* 32 + following 7-bit word:

   1:0  Button no: 0, 1, 2.  3=release.
     2  shift
     3  meta
     4  ctrl
     5  set for motion notify
     6  set for wheel
*/

/* Position: 32 - 255. */

d2908 1
a2908 1
EditorButton(TScreen * screen, XButtonEvent * event)
d2910 1
d3026 18
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.178 2005/02/04 21:40:20 tom Exp $ */
a2 1
/* $Xorg: button.c,v 1.3 2000/08/17 19:55:08 cpqbld Exp $ */
d4 1
a4 1
 * Copyright 1999-2004,2005 by Thomas E. Dickey
d54 1
a54 1
/* $XFree86: xc/programs/xterm/button.c,v 3.78 2005/02/06 21:42:37 dickey Exp $ */
d78 10
d90 1
a96 4
#define XTERM_CELL(row,col) getXtermCell(screen, row + screen->topline, col)
#define XTERM_CELL_C1(row,col) getXtermCellComb1(screen, row + screen->topline, col)
#define XTERM_CELL_C2(row,col) getXtermCellComb2(screen, row + screen->topline, col)

d115 4
a118 1
#define	Coordinate(r,c)		((r) * (term->screen.max_col+1) + (c))
d121 3
a123 25
static ANSI reply;
#endif

/* Selection/extension variables */

/* Raw char position where the selection started */
static int rawRow, rawCol;

/* Selected area before CHAR, WORD, LINE selectUnit processing */
static int startRRow, startRCol, endRRow, endRCol = 0;

/* Selected area after CHAR, WORD, LINE selectUnit processing */
static int startSRow, startSCol, endSRow, endSCol = 0;

/* Valid rows for selection clipping */
static int firstValidRow, lastValidRow;

/* Start, end of extension */
static int startERow, startECol, endERow, endECol;

/* Saved values of raw selection for extend to restore to */
static int saveStartRRow, saveStartRCol, saveEndRRow, saveEndRCol;

/* Saved value of WORD selection for LINE processing to restore to */
static int saveStartWRow, saveStartWCol;
a125 3
static int numberOfClicks = 0;
static Time lastButtonUpTime = 0;

d131 1
a131 1
static int lastButton3row, lastButton3col;	/* At the release time */
d134 2
a135 13
typedef int SelectUnit;

#define SELECTCHAR 0
#define SELECTWORD 1
#define SELECTLINE 2
#define NSELECTUNITS 3
static SelectUnit selectUnit;

/* Send emacs escape code when done selecting or extending? */
static int replyToEmacs;

static Char *SaveText(TScreen * screen, int row, int scol, int ecol, Char *
		      lp, int *eol);
d137 3
a139 4
static void ComputeSelect(int startRow, int startCol, int endRow, int
			  endCol, Bool extend);
static void EditorButton(XButtonEvent * event);
static void EndExtend(Widget w, XEvent * event, String * params, Cardinal
d141 6
a146 6
static void ExtendExtend(int row, int col);
static void PointToRowCol(int y, int x, int *r, int *c);
static void ReHiliteText(int frow, int fcol, int trow, int tcol);
static void SaltTextAway(int crow, int ccol, int row, int col, String *
			 params, Cardinal num_params);
static void SelectSet(Widget w, XEvent * event, String * params, Cardinal num_params);
d148 5
a152 4
static void StartSelect(int startrow, int startcol);
static void TrackDown(XButtonEvent * event);
static void _OwnSelection(XtermWidget termw, String * selections, Cardinal count);
static void do_select_end(Widget w, XEvent * event, String * params,
d156 1
a156 1
SendMousePosition(Widget w, XEvent * event)
d158 1
a158 6
    TScreen *screen;

    if (!IsXtermWidget(w))
	return False;

    screen = &((XtermWidget) w)->screen;
d166 1
a166 1
	return (SendLocatorPosition(w, event));
d182 1
a182 1
		EditorButton((XButtonEvent *) event);
d191 1
a191 1
	    TrackDown((XButtonEvent *) event);
d195 1
a195 1
	    EditorButton((XButtonEvent *) event);
d207 1
a207 1
	    EditorButton((XButtonEvent *) event);
d244 2
a245 2
Bool
SendLocatorPosition(Widget w, XEvent * event)
d247 2
a248 1
    TScreen *screen = &((XtermWidget) w)->screen;
d268 1
a268 1
	CheckLocatorPosition(w, event);
d282 1
d293 1
a293 1
	    MotionOff(screen, term);
d345 1
a345 1
	MotionOff(screen, term);
d357 1
a357 1
	MotionOff(screen, term);
d377 1
a377 1
GetLocatorPosition(XtermWidget w)
d379 2
a380 1
    TScreen *screen = &w->screen;
d397 1
a397 1
	MotionOff(screen, term);
d400 1
d418 1
a418 1
	    MotionOff(screen, term);
d436 1
a436 1
	MotionOff(screen, term);
d442 1
a442 1
InitLocatorFilter(XtermWidget w)
d444 2
a445 1
    TScreen *screen = &w->screen;
d470 1
d479 1
a479 1
		MotionOff(screen, term);
d488 1
a488 1
	    MotionOn(screen, term);
d536 1
d548 1
a548 1
	    MotionOff(screen, term);
d559 1
a559 1
    MotionOn(screen, term);
d562 2
a563 2
void
CheckLocatorPosition(Widget w, XEvent * event)
d565 2
a566 1
    TScreen *screen = &((XtermWidget) w)->screen;
d585 1
a585 1
	MotionOff(screen, term);
d587 1
d607 1
a607 1
	    MotionOff(screen, term);
d616 1
a616 1
isClick1_clean(XEvent * event)
a617 1
    TScreen *screen = &term->screen;
d626 1
d629 6
a634 3
    if (lastButtonDownTime == (Time) 0)		/* first time or once in a blue moon */
	delta = term->screen.multiClickTime + 1;
    else if (event->xbutton.time > lastButtonDownTime)	/* most of the time */
d636 2
a637 1
    else			/* time has rolled over since lastButtonUpTime */
d639 3
a641 1
    return delta <= term->screen.multiClickTime;
d645 1
a645 1
isDoubleClick3(XEvent * event)
d656 5
a660 4
    if (lastButton3DoubleDownTime == (Time) 0)	/* No previous click
						   or once in a blue moon */
	delta = term->screen.multiClickTime + 1;
    else if (event->xbutton.time > lastButton3DoubleDownTime)	/* most of the time */
d662 2
a663 1
    else			/* time has rolled over since lastButton3DoubleDownTime */
d665 2
a666 1
    if (delta <= term->screen.multiClickTime) {
d668 1
a668 1
	int row, col;
d671 2
a672 2
	PointToRowCol(event->xbutton.y, event->xbutton.x, &row, &col);
	if (row == lastButton3row && col == lastButton3col) {
d679 1
a679 2
    PointToRowCol(event->xbutton.y, event->xbutton.x,
		  &lastButton3row, &lastButton3col);
d684 1
a684 1
CheckSecondPress3(XEvent * event)
d686 1
a686 1
    int delta, row, col;
d695 5
a699 4
    if (lastButton3UpTime == (Time) 0)	/* No previous click
					   or once in a blue moon */
	delta = term->screen.multiClickTime + 1;
    else if (event->xbutton.time > lastButton3UpTime)	/* most of the time */
d701 2
a702 1
    else			/* time has rolled over since lastButton3UpTime */
d704 6
a709 3
    if (delta <= term->screen.multiClickTime) {
	PointToRowCol(event->xbutton.y, event->xbutton.x, &row, &col);
	if (row == lastButton3row && col == lastButton3col) {
d712 1
a712 2
	    PointToRowCol(event->xbutton.y, event->xbutton.x,
			  &lastButton3row, &lastButton3col);
d723 3
a725 1
rowOnCurrentLine(int line, int *deltap)		/* must be XButtonEvent */
a726 1
    TScreen *screen = &term->screen;
d747 1
a747 1
eventRow(XEvent * event)	/* must be XButtonEvent */
a748 2
    TScreen *screen = &term->screen;

d753 1
a753 1
eventColBetween(XEvent * event)	/* must be XButtonEvent */
a754 2
    TScreen *screen = &term->screen;

d761 1
a761 1
ReadLineMovePoint(int col, int ldelta)
a762 1
    TScreen *screen = &term->screen;
d766 1
a766 1
    col += ldelta * (screen->max_col + 1) - screen->cur_col;
d784 1
a784 1
ReadLineDelete(int r1, int c1, int r2, int c2)
a785 1
    TScreen *screen = &term->screen;
d788 1
a788 1
    del = c2 - c1 + (r2 - r1) * (screen->max_col + 1);
d792 1
a792 1
	v_write(screen->respond, "\177", 1);	/* XXX Sometimes "\08"? */
d799 1
a799 1
DiredButton(Widget w GCC_UNUSED,
d804 16
a819 13
    TScreen *screen = &term->screen;
    Char Line[6];
    unsigned line, col;

    if (event->type == ButtonPress || event->type == ButtonRelease) {
	line = (event->xbutton.y - screen->border) / FontHeight(screen);
	col = (event->xbutton.x - OriginX(screen)) / FontWidth(screen);
	Line[0] = CONTROL('X');
	Line[1] = ESC;
	Line[2] = 'G';
	Line[3] = ' ' + col;
	Line[4] = ' ' + line;
	v_write(screen->respond, Line, 5);
d825 1
a825 1
ReadLineButton(Widget w GCC_UNUSED,
d830 28
a857 3
    TScreen *screen = &term->screen;
    Char Line[6];
    int line, col, ldelta = 0;
d859 28
a886 29
    if (!(event->type == ButtonPress || event->type == ButtonRelease)
	|| (screen->send_mouse_pos != MOUSE_OFF) || ExtendingSelection)
	goto finish;
    if (event->type == ButtonRelease) {
	int delta;

	if (lastButtonDownTime == (Time) 0)	/* first time and once in a blue moon */
	    delta = screen->multiClickTime + 1;
	else if (event->xbutton.time > lastButtonDownTime)	/* most of the time */
	    delta = event->xbutton.time - lastButtonDownTime;
	else			/* time has rolled over since lastButtonUpTime */
	    delta = (((Time) ~ 0) - lastButtonDownTime) + event->xbutton.time;
	if (delta > screen->multiClickTime)
	    goto finish;	/* All this work for this... */
    }
    line = (event->xbutton.y - screen->border) / FontHeight(screen);
    if (line != screen->cur_row) {
	int l1, l2;

	if (line < screen->cur_row)
	    l1 = line, l2 = screen->cur_row;
	else
	    l2 = line, l1 = screen->cur_row;
	l1--;
	while (++l1 < l2)
	    if (!ScrnTstWrapped(screen, l1))
		goto finish;
	/* Everything is on one "wrapped line" now */
	ldelta = line - screen->cur_row;
a887 16
    /* Correct by half a width - we are acting on a boundary, not on a cell. */
    col = (event->xbutton.x - OriginX(screen) + (FontWidth(screen) - 1) / 2)
	/ FontWidth(screen) - screen->cur_col + ldelta * (screen->max_col + 1);
    if (col == 0)
	goto finish;
    Line[0] = ESC;
    /* XXX: sometimes it is better to send '['? */
    Line[1] = 'O';
    Line[2] = (col > 0 ? 'C' : 'D');
    if (col < 0)
	col = -col;
    while (col--)
	v_write(screen->respond, Line, 3);
  finish:
    if (event->type == ButtonRelease)
	do_select_end(w, event, params, num_params, False);
d893 1
a893 1
ViButton(Widget w GCC_UNUSED,
d898 14
a911 4
    TScreen *screen = &term->screen;
    int pty = screen->respond;
    Char Line[6];
    int line;
d913 8
a920 13
    if (event->type == ButtonPress || event->type == ButtonRelease) {

	line = screen->cur_row -
	    ((event->xbutton.y - screen->border) / FontHeight(screen));
	if (line != 0) {
	    Line[0] = ESC;	/* force an exit from insert-mode */
	    v_write(pty, Line, 1);

	    if (line < 0) {
		line = -line;
		Line[0] = CONTROL('n');
	    } else {
		Line[0] = CONTROL('p');
a921 2
	    while (--line >= 0)
		v_write(pty, Line, 1);
d936 13
a948 2
    TScreen *screen;
    int row, col;
d950 12
a961 2
    if (!IsXtermWidget(w))
	return;
d963 9
a971 20
    screen = &((XtermWidget) w)->screen;
    screen->selection_time = event->xmotion.time;
    switch (eventMode) {
	/* If not in one of the DEC mouse-reporting modes */
    case LEFTEXTENSION:
    case RIGHTEXTENSION:
	PointToRowCol(event->xmotion.y, event->xmotion.x,
		      &row, &col);
	ExtendExtend(row, col);
	break;

	/* If in motion reporting mode, send mouse position to
	   character process as a key sequence \E[M... */
    case NORMAL:
	/* will get here if send_mouse_pos != MOUSE_OFF */
	if (screen->send_mouse_pos == BTN_EVENT_MOUSE
	    || screen->send_mouse_pos == ANY_EVENT_MOUSE) {
	    (void) SendMousePosition(w, event);
	}
	break;
d976 1
a976 1
do_select_end(Widget w,
d984 1
a984 1
    TScreen *screen = &term->screen;
d987 1
a987 5
    if (!IsXtermWidget(w)) {
	return;
    }

    ((XtermWidget) w)->screen.selection_time = event->xbutton.time;
d990 1
a990 1
	(void) SendMousePosition(w, event);
d994 1
a994 1
	EndExtend(w, event, params, *num_params, use_cursor_loc);
d996 1
a996 1
	if (isClick1_clean(event)
d998 2
a999 2
	    && rowOnCurrentLine(eventRow(event), &ldelta1)) {
	    ReadLineMovePoint(eventColBetween(event), ldelta1);
d1001 1
a1001 1
	if (isDoubleClick3(event)
d1003 4
a1006 4
	    && rowOnCurrentLine(startSRow, &ldelta1)
	    && rowOnCurrentLine(endSRow, &ldelta2)) {
	    ReadLineMovePoint(endSCol, ldelta2);
	    ReadLineDelete(startSRow, startSCol, endSRow, endSCol);
d1019 2
a1020 1
    do_select_end(w, event, params, num_params, False);
d1029 2
a1030 1
    do_select_end(w, event, params, num_params, True);
d1040 3
a1042 3
/* convert a UTF-8 string to Latin-1, replacing non Latin-1 characters
 * by `#'. */

d1143 64
d1247 1
d1249 19
a1267 5
_GetSelection(Widget w,
	      Time ev_time,
	      String * params,	/* selections in precedence order */
	      Cardinal num_params,
	      Atom * targets)
d1276 2
a1277 9
#if OPT_TRACE
    TRACE(("_GetSelection\n"));
    if (num_params > 0) {
	Cardinal n;
	for (n = 0; n < num_params; ++n) {
	    TRACE(("param[%d]:%s\n", n, params[n]));
	}
    }
#endif
d1281 1
d1284 1
d1295 1
d1299 8
a1306 2
	else if (num_params > 1)
	    _GetSelection(w, ev_time, params + 1, num_params - 1, NULL);
d1356 9
a1364 3
    Trace("Getting %s (%ld)\n", name, (long int) type);
    for (cp = line; cp < line + len; cp++)
	Trace("%c\n", *cp);
d1376 32
d1411 41
d1455 1
a1455 1
	    tty_vwrite(screen->respond, "\026", 1);	/* Control-V */
d1470 1
a1470 1
    Char *lag, *cp, *end;
d1482 16
a1497 6
    if (!SCREEN_FLAG(screen, paste_literal_nl)) {
	for (cp = line; cp != end; cp++) {
	    if (*cp == '\n') {
		*cp = '\r';
		_qWriteSelectionData(screen, lag, (unsigned) (cp - lag + 1));
		lag = cp + 1;
d1500 4
a1503 3
    }
    if (lag != end) {
	_qWriteSelectionData(screen, lag, (unsigned) (end - lag));
d1515 1
a1515 1
    char line[16];
d1517 1
a1517 1
    unsigned length = strlen(in);
d1542 1
a1542 1
		  int *format GCC_UNUSED)
d1614 5
d1620 3
a1622 2
	if (SCREEN_FLAG(screen, paste_brackets))
	    _WriteKey(screen, "200");
d1628 5
d1634 3
a1636 2
	if (SCREEN_FLAG(screen, paste_brackets))
	    _WriteKey(screen, "201");
d1650 2
a1651 2
	_GetSelection(w, list->time,
		      list->params, list->count, list->targets);
d1653 4
d1667 2
a1668 7
#if OPT_READLINE
    int ldelta;
    TScreen *screen = &((XtermWidget) w)->screen;
#endif

    if (SendMousePosition(w, event))
	return;
d1670 1
d1672 9
a1680 7
    if ((event->type == ButtonPress || event->type == ButtonRelease)
    /* Disable on Shift-mouse, including the application-mouse modes */
	&& !(KeyModifiers & ShiftMask)
	&& (screen->send_mouse_pos == MOUSE_OFF)
	&& SCREEN_FLAG(screen, paste_moves)
	&& rowOnCurrentLine(eventRow(event), &ldelta))
	ReadLineMovePoint(eventColBetween(event), ldelta);
d1683 3
a1685 1
    _GetSelection(w, event->xbutton.time, params, *num_params, NULL);
d1689 1
a1689 1
EvalSelectUnit(Time buttonDownTime, SelectUnit defaultUnit)
d1691 1
d1694 10
a1703 6
    if (lastButtonUpTime == (Time) 0)	/* first time and once in a blue moon */
	delta = term->screen.multiClickTime + 1;
    else if (buttonDownTime > lastButtonUpTime)		/* most of the time */
	delta = buttonDownTime - lastButtonUpTime;
    else			/* time has rolled over since lastButtonUpTime */
	delta = (((Time) ~ 0) - lastButtonUpTime) + buttonDownTime;
d1705 3
a1707 3
    if (delta > term->screen.multiClickTime) {
	numberOfClicks = 1;
	return defaultUnit;
d1709 2
a1710 2
	++numberOfClicks;
	return ((selectUnit + 1) % NSELECTUNITS);
d1712 2
d1717 1
a1717 1
do_select_start(Widget w,
d1719 1
a1719 2
		int startrow,
		int startcol)
d1721 3
a1723 1
    if (SendMousePosition(w, event))
d1725 2
a1726 2
    selectUnit = EvalSelectUnit(event->xbutton.time, SELECTCHAR);
    replyToEmacs = False;
d1732 1
a1732 1
    StartSelect(startrow, startcol);
d1742 8
a1749 10
    TScreen *screen;
    int startrow, startcol;

    if (!IsXtermWidget(w))
	return;

    screen = &((XtermWidget) w)->screen;
    firstValidRow = 0;
    lastValidRow = screen->max_row;
    PointToRowCol(event->xbutton.y, event->xbutton.x, &startrow, &startcol);
d1752 1
a1752 1
    ExtendingSelection = 0;
d1755 2
a1756 1
    do_select_start(w, event, startrow, startcol);
d1766 5
a1770 7
    TScreen *screen;

    if (!IsXtermWidget(w))
	return;

    screen = &((XtermWidget) w)->screen;
    do_select_start(w, event, screen->cursor_row, screen->cursor_col);
d1774 1
a1774 1
TrackDown(XButtonEvent * event)
d1776 1
a1776 1
    int startrow, startcol;
d1778 5
a1782 5
    selectUnit = EvalSelectUnit(event->time, SELECTCHAR);
    if (numberOfClicks > 1) {
	PointToRowCol(event->y, event->x, &startrow, &startcol);
	replyToEmacs = True;
	StartSelect(startrow, startcol);
d1784 2
a1785 2
	waitingForTrackInfo = 1;
	EditorButton((XButtonEvent *) event);
d1792 1
a1792 1
			    x = screen->max_row;
d1795 5
a1799 1
TrackMouse(int func, int startrow, int startcol, int firstrow, int lastrow)
d1801 4
a1804 1
    TScreen *screen = &term->screen;
d1806 8
a1813 2
    if (!waitingForTrackInfo) {	/* Timed out, so ignore */
	return;
a1814 10
    waitingForTrackInfo = 0;
    if (func == 0)
	return;
    boundsCheck(startrow)
	boundsCheck(firstrow)
	boundsCheck(lastrow)
	firstValidRow = firstrow;
    lastValidRow = lastrow;
    replyToEmacs = True;
    StartSelect(startrow, startcol);
d1818 1
a1818 1
StartSelect(int startrow, int startcol)
d1820 1
a1820 3
    TScreen *screen = &term->screen;

    TRACE(("StartSelect row=%d, col=%d\n", startrow, startcol));
d1823 1
a1823 1
    if (numberOfClicks == 1) {
d1825 1
a1825 3
	rawRow = startrow;
	rawCol = startcol;

d1827 4
a1830 6
    /* else use old values in rawRow, Col */
    saveStartRRow = startERow = rawRow;
    saveStartRCol = startECol = rawCol;
    saveEndRRow = endERow = rawRow;
    saveEndRCol = endECol = rawCol;
    if (Coordinate(startrow, startcol) < Coordinate(rawRow, rawCol)) {
d1832 1
a1832 2
	startERow = startrow;
	startECol = startcol;
d1835 1
a1835 2
	endERow = startrow;
	endECol = startcol;
d1837 1
a1837 1
    ComputeSelect(startERow, startECol, endERow, endECol, False);
d1841 1
a1841 1
EndExtend(Widget w,
d1847 1
a1847 1
    int row, col;
d1849 1
a1849 1
    TScreen *screen = &term->screen;
d1853 1
a1853 2
	row = screen->cursor_row;
	col = screen->cursor_col;
d1855 1
a1855 1
	PointToRowCol(event->xbutton.y, event->xbutton.x, &row, &col);
d1857 4
a1860 4
    ExtendExtend(row, col);
    lastButtonUpTime = event->xbutton.time;
    if (startSRow != endSRow || startSCol != endSCol) {
	if (replyToEmacs) {
d1868 2
a1869 2
	    if (rawRow == startSRow && rawCol == startSCol
		&& row == endSRow && col == endSCol) {
d1872 2
a1873 2
		line[count++] = ' ' + endSCol + 1;
		line[count++] = ' ' + endSRow + 1;
d1877 6
a1882 6
		line[count++] = ' ' + startSCol + 1;
		line[count++] = ' ' + startSRow + 1;
		line[count++] = ' ' + endSCol + 1;
		line[count++] = ' ' + endSRow + 1;
		line[count++] = ' ' + col + 1;
		line[count++] = ' ' + row + 1;
d1885 1
a1885 1
	    TrackText(0, 0, 0, 0);
d1888 1
a1888 1
    SelectSet(w, event, params, num_params);
d1898 3
a1900 1
    SelectSet(w, event, params, *num_params);
d1905 1
a1905 1
SelectSet(Widget w GCC_UNUSED,
d1910 2
d1914 2
a1915 3
    if (startSRow != endSRow || startSCol != endSCol) {
	SaltTextAway(startSRow, startSCol, endSRow, endSCol,
		     params, num_params);
d1917 1
a1917 1
	DisownSelection(term);
d1925 1
a1925 1
do_start_extend(Widget w,
d1931 3
a1933 2
    TScreen *screen;
    int row, col, coord;
d1935 1
a1935 1
    if (!IsXtermWidget(w))
d1938 1
a1938 2
    screen = &((XtermWidget) w)->screen;
    if (SendMousePosition(w, event))
d1940 3
a1942 2
    firstValidRow = 0;
    lastValidRow = screen->max_row;
d1948 2
a1949 2
	selectUnit = EvalSelectUnit(event->xbutton.time, selectUnit);
    replyToEmacs = False;
d1952 1
a1952 1
    CheckSecondPress3(event);
d1955 1
a1955 1
    if (numberOfClicks == 1
d1960 2
a1961 4
	saveStartRRow = startERow = startRRow;
	saveStartRCol = startECol = startRCol;
	saveEndRRow = endERow = endRRow;
	saveEndRCol = endECol = endRCol;
d1964 2
a1965 5
	startERow = startRRow = saveStartRRow;
	startECol = startRCol = saveStartRCol;
	endERow = endRRow = saveEndRRow;
	endECol = endRCol = saveEndRCol;

d1968 1
a1968 2
	row = screen->cursor_row;
	col = screen->cursor_col;
d1970 1
a1970 1
	PointToRowCol(event->xbutton.y, event->xbutton.x, &row, &col);
d1972 1
a1972 1
    coord = Coordinate(row, col);
d1974 3
a1976 3
    if (Abs(coord - Coordinate(startSRow, startSCol))
	< Abs(coord - Coordinate(endSRow, endSCol))
	|| coord < Coordinate(startSRow, startSCol)) {
d1979 1
a1979 2
	startERow = row;
	startECol = col;
d1983 1
a1983 2
	endERow = row;
	endECol = col;
d1985 1
a1985 1
    ComputeSelect(startERow, startECol, endERow, endECol, True);
d1988 1
a1988 1
    if (startSRow != endSRow || startSCol != endSCol)
d1994 1
a1994 1
ExtendExtend(int row, int col)
d1996 1
a1996 1
    int coord = Coordinate(row, col);
d1998 1
a1998 1
    TRACE(("ExtendExtend row=%d, col=%d\n", row, col));
d2000 2
a2001 1
	&& (coord + (selectUnit != SELECTCHAR)) > Coordinate(endSRow, endSCol)) {
d2004 1
a2004 2
	startERow = saveStartRRow;
	startECol = saveStartRCol;
d2006 1
a2006 1
	       && coord < Coordinate(startSRow, startSCol)) {
d2009 1
a2009 2
	endERow = saveEndRRow;
	endECol = saveEndRCol;
d2012 1
a2012 2
	startERow = row;
	startECol = col;
d2014 1
a2014 2
	endERow = row;
	endECol = col;
d2016 1
a2016 1
    ComputeSelect(startERow, startECol, endERow, endECol, False);
d2019 1
a2019 1
    if (startSRow != endSRow || startSCol != endSCol)
d2030 2
a2031 1
    do_start_extend(w, event, params, num_params, False);
d2040 2
a2041 1
    do_start_extend(w, event, params, num_params, True);
d2047 2
a2048 2
    int minrow = -screen->savedlines - screen->topline;
    int maxrow = screen->max_row - screen->topline;
d2051 5
a2055 5
#define scroll_update_one(row, col) \
	row += amount; \
	if (row < minrow) { \
	    row = minrow; \
	    col = 0; \
d2057 3
a2059 3
	if (row > maxrow) { \
	    row = maxrow; \
	    col = maxcol; \
d2062 4
a2065 4
    scroll_update_one(startRRow, startRCol);
    scroll_update_one(endRRow, endRCol);
    scroll_update_one(startSRow, startSCol);
    scroll_update_one(endSRow, endSCol);
d2067 1
a2067 1
    scroll_update_one(rawRow, rawCol);
d2079 1
a2079 1
	adjust = screen->startHRow + screen->topline;
d2083 1
a2083 1
	    scroll_update_one(screen->startHRow, screen->startHCol);
d2085 1
a2085 1
	adjust = screen->endHRow + screen->topline;
d2089 1
a2089 1
	    scroll_update_one(screen->endHRow, screen->endHCol);
d2093 2
a2094 2
    screen->startHCoord = Coordinate(screen->startHRow, screen->startHCol);
    screen->endHCoord = Coordinate(screen->endHRow, screen->endHCol);
d2104 21
a2124 21
    if (startRRow > rows)
	startRRow = rows;
    if (startSRow > rows)
	startSRow = rows;
    if (endRRow > rows)
	endRRow = rows;
    if (endSRow > rows)
	endSRow = rows;
    if (rawRow > rows)
	rawRow = rows;

    if (startRCol > cols)
	startRCol = cols;
    if (startSCol > cols)
	startSCol = cols;
    if (endRCol > cols)
	endRCol = cols;
    if (endSCol > cols)
	endSCol = cols;
    if (rawCol > cols)
	rawCol = cols;
d2138 4
a2141 4
PointToRowCol(int y,
	      int x,
	      int *r,
	      int *c)
d2147 10
a2156 13
    TScreen *screen = &term->screen;
    int row, col;

    row = (y - screen->border) / FontHeight(screen);
    if (row < firstValidRow)
	row = firstValidRow;
    else if (row > lastValidRow)
	row = lastValidRow;
    col = (x - OriginX(screen)) / FontWidth(screen);
    if (col < 0)
	col = 0;
    else if (col > screen->max_col + 1) {
	col = screen->max_col + 1;
d2163 4
a2166 4
    if (col > 0
	&& isWideCell(row, col - 1)
	&& (XTERM_CELL(row, col) == HIDDEN_CHAR)) {
	col -= 1;
a2168 2
    *r = row;
    *c = col;
d2171 3
d2175 1
a2175 1
LastTextCol(int row)
d2177 1
a2177 1
    TScreen *screen = &term->screen;
d2181 1
a2181 1
    if ((row += screen->topline) + screen->savedlines >= 0) {
d2183 1
a2183 1
	     ch = SCRN_BUF_ATTRS(screen, row) + i;
d2187 1
a2187 1
	if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, row)[0])) {
d2295 1
a2295 1
class_of(TScreen * screen, int row, int col)
d2297 1
d2299 1
d2301 2
a2302 2
    if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, row + screen->topline)[0])) {
	col /= 2;
d2305 2
a2306 1
    value = XTERM_CELL(row, col);
d2312 3
a2314 3
#define ClassSelects(screen, row, col, cclass) \
	 (class_of(screen, row, col) == cclass \
	 || XTERM_CELL(row, col) == HIDDEN_CHAR)
d2316 3
a2318 3
#define class_of(screen,row,col) charClass[XTERM_CELL(row, col)]
#define ClassSelects(screen, row, col, cclass) \
	 (class_of(screen,row, col) == cclass)
d2322 263
a2584 1
 * sets startSRow startSCol endSRow endSCol
d2588 3
a2590 4
ComputeSelect(int startRow,
	      int startCol,
	      int endRow,
	      int endCol,
a2592 1
    TScreen *screen = &term->screen;
d2595 2
d2599 3
a2601 1
	   startRow, startCol, endRow, endCol, extend ? "" : "no"));
d2604 13
a2616 13
    if (startCol > 1
	&& isWideCell(startRow, startCol - 1)
	&& XTERM_CELL(startRow, startCol - 0) == HIDDEN_CHAR) {
	fprintf(stderr, "Adjusting start. Changing downwards from %i.\n", startCol);
	startCol -= 1;
	if (endCol == (startCol + 1))
	    endCol--;
    }

    if (endCol > 1
	&& isWideCell(endRow, endCol - 1)
	&& XTERM_CELL(endRow, endCol) == HIDDEN_CHAR) {
	endCol += 1;
d2620 3
a2622 5
    if (Coordinate(startRow, startCol) <= Coordinate(endRow, endCol)) {
	startSRow = startRRow = startRow;
	startSCol = startRCol = startCol;
	endSRow = endRRow = endRow;
	endSCol = endRCol = endCol;
d2624 14
a2637 23
	startSRow = startRRow = endRow;
	startSCol = startRCol = endCol;
	endSRow = endRRow = startRow;
	endSCol = endRCol = startCol;
    }

    switch (selectUnit) {
    case SELECTCHAR:
	if (startSCol > (LastTextCol(startSRow) + 1)) {
	    startSCol = 0;
	    startSRow++;
	}
	if (endSCol > (LastTextCol(endSRow) + 1)) {
	    endSCol = 0;
	    endSRow++;
	}
	break;
    case SELECTWORD:
	if (startSCol > (LastTextCol(startSRow) + 1)) {
	    startSCol = 0;
	    startSRow++;
	} else {
	    cclass = class_of(screen, startSRow, startSCol);
d2639 6
a2644 5
		--startSCol;
		if (startSCol < 0
		    && ScrnTstWrapped(screen, startSRow - 1)) {
		    --startSRow;
		    startSCol = LastTextCol(startSRow);
d2646 3
a2648 3
	    } while (startSCol >= 0
		     && ClassSelects(screen, startSRow, startSCol, cclass));
	    ++startSCol;
a2649 1

d2651 4
a2654 2
	if (startSCol && XTERM_CELL(startSRow, startSCol) == HIDDEN_CHAR)
	    startSCol++;
d2657 3
a2659 6
	if (endSCol > (LastTextCol(endSRow) + 1)) {
	    endSCol = 0;
	    endSRow++;
	} else {
	    length = LastTextCol(endSRow);
	    cclass = class_of(screen, endSRow, endSCol);
d2661 6
a2666 6
		++endSCol;
		if (endSCol > length
		    && ScrnTstWrapped(screen, endSRow)) {
		    endSCol = 0;
		    ++endSRow;
		    length = LastTextCol(endSRow);
d2668 9
a2676 9
	    } while (endSCol <= length
		     && ClassSelects(screen, endSRow, endSCol, cclass));
	    /* Word select selects if pointing to any char
	       in "word", especially in that it includes
	       the last character in a word.  So no --endSCol
	       and do special eol handling */
	    if (endSCol > length + 1) {
		endSCol = 0;
		++endSRow;
a2678 1

d2680 4
a2683 2
	if (endSCol && XTERM_CELL(endSRow, endSCol) == HIDDEN_CHAR)
	    endSCol++;
d2686 1
a2686 2
	saveStartWRow = startSRow;
	saveStartWCol = startSCol;
d2688 12
a2699 9
    case SELECTLINE:
	while (ScrnTstWrapped(screen, endSRow)) {
	    ++endSRow;
	}
	if (term->screen.cutToBeginningOfLine
	    || startSRow < saveStartWRow) {
	    startSCol = 0;
	    while (ScrnTstWrapped(screen, startSRow - 1)) {
		--startSRow;
d2702 7
a2708 6
	    if ((startRow < saveStartWRow)
		|| (startRow == saveStartWRow
		    && startCol < saveStartWCol)) {
		startSCol = 0;
		while (ScrnTstWrapped(screen, startSRow - 1)) {
		    --startSRow;
d2711 1
a2711 2
		startSRow = saveStartWRow;
		startSCol = saveStartWCol;
d2714 20
a2733 5
	if (term->screen.cutNewline) {
	    endSCol = 0;
	    ++endSRow;
	} else {
	    endSCol = LastTextCol(endSRow) + 1;
d2736 25
d2766 1
a2766 1
    TrackText(startSRow, startSCol, endSRow, endSCol);
d2770 5
a2774 6
void
TrackText(int frow,
	  int fcol,
	  int trow,
	  int tcol)
    /* Guaranteed (frow, fcol) <= (trow, tcol) */
d2777 16
a2792 19
    TScreen *screen = &term->screen;
    int old_startrow, old_startcol, old_endrow, old_endcol;

    TRACE(("TrackText(frow=%d, fcol=%d, trow=%d, tcol=%d)\n",
	   frow, fcol, trow, tcol));

    old_startrow = screen->startHRow;
    old_startcol = screen->startHCol;
    old_endrow = screen->endHRow;
    old_endcol = screen->endHCol;
    if (frow == old_startrow && fcol == old_startcol &&
	trow == old_endrow && tcol == old_endcol)
	return;
    screen->startHRow = frow;
    screen->startHCol = fcol;
    screen->endHRow = trow;
    screen->endHCol = tcol;
    from = Coordinate(frow, fcol);
    to = Coordinate(trow, tcol);
d2795 2
a2796 2
	ReHiliteText(old_startrow, old_startcol, old_endrow, old_endcol);
	ReHiliteText(frow, fcol, trow, tcol);
d2800 1
a2800 1
	    ReHiliteText(frow, fcol, old_startrow, old_startcol);
d2803 1
a2803 1
	    ReHiliteText(old_startrow, old_startcol, frow, fcol);
d2807 1
a2807 1
	    ReHiliteText(old_endrow, old_endcol, trow, tcol);
d2810 1
a2810 1
	    ReHiliteText(trow, tcol, old_endrow, old_endcol);
d2817 1
d2819 3
a2821 5
ReHiliteText(int frow,
	     int fcol,
	     int trow,
	     int tcol)
    /* Guaranteed that (frow, fcol) <= (trow, tcol) */
a2822 1
    TScreen *screen = &term->screen;
d2824 2
d2827 2
a2828 1
    TRACE(("ReHiliteText from %d.%d to %d.%d\n", frow, fcol, trow, tcol));
d2830 10
a2839 10
    if (frow < 0)
	frow = fcol = 0;
    else if (frow > screen->max_row)
	return;			/* nothing to do, since trow >= frow */

    if (trow < 0)
	return;			/* nothing to do, since frow <= trow */
    else if (trow > screen->max_row) {
	trow = screen->max_row;
	tcol = screen->max_col + 1;
d2841 1
a2841 1
    if (frow == trow && fcol == tcol)
d2844 3
a2846 3
    if (frow != trow) {		/* do multiple rows */
	if ((i = screen->max_col - fcol + 1) > 0) {	/* first row */
	    ScrnRefresh(screen, frow, fcol, 1, i, True);
d2848 2
a2849 2
	if ((i = trow - frow - 1) > 0) {	/* middle rows */
	    ScrnRefresh(screen, frow + 1, 0, i, screen->max_col + 1, True);
d2851 2
a2852 2
	if (tcol > 0 && trow <= screen->max_row) {	/* last row */
	    ScrnRefresh(screen, trow, 0, 1, tcol, True);
d2855 1
a2855 1
	ScrnRefresh(screen, frow, fcol, 1, tcol - fcol, True);
d2859 4
d2864 3
a2866 1
SaltTextAway(int crow, int ccol, int row, int col,
a2868 2
    /* Guaranteed that (crow, ccol) <= (row, col), and that both points are valid
       (may have row = screen->max_row+1, col = 0) */
d2870 1
a2870 1
    TScreen *screen = &term->screen;
d2875 2
d2878 4
a2881 4
    if (crow == row && ccol > col) {
	int tmp = ccol;
	ccol = col;
	col = tmp;
d2884 1
a2884 1
    --col;
d2887 2
a2888 2
    if (row == crow) {
	j = Length(screen, crow, ccol, col);
d2890 2
a2891 2
	j += Length(screen, crow, ccol, screen->max_col) + 1;
	for (i = crow + 1; i < row; i++)
d2893 2
a2894 2
	if (col >= 0)
	    j += Length(screen, row, 0, col);
d2920 2
a2921 2
    if (row == crow) {
	lp = SaveText(screen, row, ccol, col, lp, &eol);
d2923 1
a2923 1
	lp = SaveText(screen, crow, ccol, screen->max_col, lp, &eol);
d2926 1
a2926 1
	for (i = crow + 1; i < row; i++) {
d2931 2
a2932 2
	if (col >= 0)
	    lp = SaveText(screen, row, 0, col, lp, &eol);
d2938 9
a2946 1
    _OwnSelection(term, params, num_params);
d2949 88
d3039 4
a3042 2
			Atom * type, XtPointer *value,
			unsigned long *length, int *format,
d3049 16
a3064 18
    Display *d = XtDisplay(w);
    TScreen *screen;
    XTextProperty textprop;

    if (!IsXtermWidget(w))
	return False;

    screen = &((XtermWidget) w)->screen;

    if (conversion_function(d, (char **) &screen->selection_data, 1,
			    conversion_style,
			    &textprop) < Success)
	return False;
    *value = (XtPointer) textprop.value;
    *length = textprop.nitems;
    *type = textprop.encoding;
    *format = textprop.format;
    return True;
d3093 2
d3125 1
d3132 1
d3139 1
d3146 1
d3162 1
d3169 1
d3176 1
d3185 1
d3194 1
d3207 1
d3224 1
d3266 1
a3266 1
	TrackText(0, 0, 0, 0);
d3279 1
a3279 1
_OwnSelection(XtermWidget termw,
d3283 2
a3284 1
    Atom *atoms = termw->screen.selection_atoms;
d3288 1
a3288 1
    if (termw->screen.selection_length < 0)
d3291 4
a3294 1
    if (count > termw->screen.sel_atoms_size) {
d3297 2
a3298 2
	termw->screen.selection_atoms = atoms;
	termw->screen.sel_atoms_size = count;
d3300 1
a3300 1
    XmuInternStrings(XtDisplay((Widget) termw), selections, count, atoms);
d3304 2
a3305 2
	    if (termw->screen.selection_length >
		4 * XMaxRequestSize(XtDisplay((Widget) termw)) - 32) {
d3308 1
a3308 1
			xterm_name, termw->screen.selection_length, cutbuffer);
d3315 3
a3317 3
		unsigned long length = termw->screen.selection_length;
		Char *data = termw->screen.selection_data;
		if_OPT_WIDE_CHARS((&(termw->screen)), {
d3321 1
a3321 1
		XStoreBuffer(XtDisplay((Widget) termw),
d3326 1
a3326 1
	} else if (!replyToEmacs) {
d3328 2
a3329 2
		XtOwnSelection((Widget) termw, atoms[i],
			       termw->screen.selection_time,
d3333 2
a3334 2
    if (!replyToEmacs)
	termw->screen.selection_count = count;
d3336 1
a3336 1
	TrackText(0, 0, 0, 0);
d3343 2
a3344 2
    screen->startHRow = screen->startHCol = 0;
    screen->endHRow = screen->endHCol = 0;
d3348 1
a3348 1
DisownSelection(XtermWidget termw)
d3350 1
a3350 1
    TScreen *screen = &(termw->screen);
d3357 4
a3360 4
	   screen->startHRow,
	   screen->startHCol,
	   screen->endHRow,
	   screen->endHCol));
d3365 1
a3365 1
	    XtDisownSelection((Widget) termw, atoms[i],
d3375 2
a3376 4
	int start_row = screen->startHRow;
	int start_col = screen->startHCol;
	int end_row = screen->endHRow;
	int end_col = screen->endHCol;
d3379 1
a3379 1
	ReHiliteText(start_row, start_col, end_row, end_col);
d3393 1
a3393 1
    int lastcol = LastTextCol(row);
d3420 1
a3420 1
    if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, row + screen->topline)[0])) {
d3429 1
a3429 1
	if (screen->utf8_mode) {
d3449 1
a3449 1
	if (screen->utf8_mode) {
d3485 12
d3517 1
a3517 1
EditorButton(XButtonEvent * event)
a3518 1
    TScreen *screen = &term->screen;
a3633 18

/* ARGSUSED */
void
HandleSecure(Widget w GCC_UNUSED,
	     XEvent * event,	/* unused */
	     String * params GCC_UNUSED,	/* [0] = volume */
	     Cardinal *param_count GCC_UNUSED)	/* 0 or 1 */
{
    Time ev_time = CurrentTime;

    if ((event->xany.type == KeyPress) ||
	(event->xany.type == KeyRelease))
	ev_time = event->xkey.time;
    else if ((event->xany.type == ButtonPress) ||
	     (event->xany.type == ButtonRelease))
	ev_time = event->xbutton.time;
    DoSecureKeyboard(ev_time);
}
@


1.1.109.1
log
@Import xterm-215 (latest from Tom Dickey)
XFree86 4.6.0 had xterm-213 with no diffs,
so we only need to care about both obsd and
mbsd local diffs
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.246 2006/06/19 00:36:50 tom Exp $ */
d3 1
d5 1
a5 1
 * Copyright 1999-2005,2006 by Thomas E. Dickey
d55 1
a55 1
/* $XFree86: xc/programs/xterm/button.c,v 3.88 2006/06/19 00:36:50 dickey Exp $ */
a78 10
#include <xstrings.h>

#if OPT_SELECT_REGEX
#ifdef HAVE_PCREPOSIX_H
#include <pcreposix.h>
#else /* POSIX regex.h */
#include <sys/types.h>
#include <regex.h>
#endif
#endif
a80 1
#include <ctype.h>
d87 4
d109 19
a127 1
#define	Coordinate(s,c)	((c)->row * MaxCols(s) + (c)->col)
d129 2
a130 2
static const CELL zeroCELL =
{0, 0};
d132 5
a136 4
#if OPT_DEC_LOCATOR
static Bool SendLocatorPosition(XtermWidget xw, XEvent * event);
static void CheckLocatorPosition(XtermWidget xw, XEvent * event);
#endif /* OPT_DEC_LOCATOR */
d139 3
d147 1
a147 1
static CELL lastButton3;	/* At the release time */
d150 13
a162 2
static Char *SaveText(TScreen * screen, int row, int scol, int ecol,
		      Char * lp, int *eol);
d164 4
a167 3
static void ComputeSelect(TScreen * screen, CELL * startc, CELL * endc, Bool extend);
static void EditorButton(TScreen * screen, XButtonEvent * event);
static void EndExtend(XtermWidget w, XEvent * event, String * params, Cardinal
d169 6
a174 6
static void ExtendExtend(TScreen * screen, const CELL * cell);
static void PointToCELL(TScreen * screen, int y, int x, CELL * cell);
static void ReHiliteText(TScreen * screen, CELL * first, CELL * last);
static void SaltTextAway(XtermWidget xw, CELL * cellc, CELL * cell,
			 String * params, Cardinal num_params);
static void SelectSet(XtermWidget xw, XEvent * event, String * params, Cardinal num_params);
d176 4
a179 5
static void StartSelect(TScreen * screen, const CELL * cell);
static void TrackDown(TScreen * screen, XButtonEvent * event);
static void TrackText(TScreen * screen, const CELL * first, const CELL * last);
static void _OwnSelection(XtermWidget xw, String * selections, Cardinal count);
static void do_select_end(XtermWidget xw, XEvent * event, String * params,
d183 1
a183 1
SendMousePosition(XtermWidget xw, XEvent * event)
d185 6
a190 1
    TScreen *screen = &(xw->screen);
d198 1
a198 1
	return (SendLocatorPosition(xw, event));
d214 1
a214 1
		EditorButton(screen, (XButtonEvent *) event);
d223 1
a223 1
	    TrackDown(screen, (XButtonEvent *) event);
d227 1
a227 1
	    EditorButton(screen, (XButtonEvent *) event);
d239 1
a239 1
	    EditorButton(screen, (XButtonEvent *) event);
d276 2
a277 2
static Bool
SendLocatorPosition(XtermWidget xw, XEvent * event)
d279 1
a279 2
    ANSI reply;
    TScreen *screen = &(xw->screen);
d299 1
a299 1
	CheckLocatorPosition(xw, event);
a312 1
    memset(&reply, 0, sizeof(reply));
d323 1
a323 1
	    MotionOff(screen, xw);
d375 1
a375 1
	MotionOff(screen, xw);
d387 1
a387 1
	MotionOff(screen, xw);
d407 1
a407 1
GetLocatorPosition(XtermWidget xw)
d409 1
a409 2
    ANSI reply;
    TScreen *screen = &xw->screen;
d426 1
a426 1
	MotionOff(screen, xw);
a428 1
    memset(&reply, 0, sizeof(reply));
d446 1
a446 1
	    MotionOff(screen, xw);
d464 1
a464 1
	MotionOff(screen, xw);
d470 1
a470 1
InitLocatorFilter(XtermWidget xw)
d472 1
a472 2
    ANSI reply;
    TScreen *screen = &xw->screen;
a496 1
	    memset(&reply, 0, sizeof(reply));
d505 1
a505 1
		MotionOff(screen, xw);
d514 1
a514 1
	    MotionOn(screen, xw);
a561 1
	memset(&reply, 0, sizeof(reply));
d573 1
a573 1
	    MotionOff(screen, xw);
d584 1
a584 1
    MotionOn(screen, xw);
d587 2
a588 2
static void
CheckLocatorPosition(XtermWidget xw, XEvent * event)
d590 1
a590 2
    ANSI reply;
    TScreen *screen = &(xw->screen);
d609 1
a609 1
	MotionOff(screen, xw);
a610 1
	memset(&reply, 0, sizeof(reply));
d630 1
a630 1
	    MotionOff(screen, xw);
d639 1
a639 1
isClick1_clean(TScreen * screen, XEvent * event)
d641 1
a649 1

d652 3
a654 6

    if (lastButtonDownTime == (Time) 0) {
	/* first time or once in a blue moon */
	delta = screen->multiClickTime + 1;
    } else if (event->xbutton.time > lastButtonDownTime) {
	/* most of the time */
d656 1
a656 2
    } else {
	/* time has rolled over since lastButtonUpTime */
d658 1
a658 3
    }

    return delta <= screen->multiClickTime;
d662 1
a662 1
isDoubleClick3(TScreen * screen, XEvent * event)
d673 4
a676 5
    if (lastButton3DoubleDownTime == (Time) 0) {
	/* No previous click or once in a blue moon */
	delta = screen->multiClickTime + 1;
    } else if (event->xbutton.time > lastButton3DoubleDownTime) {
	/* most of the time */
d678 1
a678 2
    } else {
	/* time has rolled over since lastButton3DoubleDownTime */
d680 1
a680 2
    }
    if (delta <= screen->multiClickTime) {
d682 1
a682 1
	CELL cell;
d685 2
a686 2
	PointToCELL(screen, event->xbutton.y, event->xbutton.x, &cell);
	if (isSameCELL(&cell, &lastButton3)) {
d693 2
a694 1
    PointToCELL(screen, event->xbutton.y, event->xbutton.x, &lastButton3);
d699 1
a699 1
CheckSecondPress3(TScreen * screen, XEvent * event)
d701 1
a701 1
    int delta;
d710 4
a713 5
    if (lastButton3UpTime == (Time) 0) {
	/* No previous click or once in a blue moon */
	delta = screen->multiClickTime + 1;
    } else if (event->xbutton.time > lastButton3UpTime) {
	/* most of the time */
d715 1
a715 2
    } else {
	/* time has rolled over since lastButton3UpTime */
d717 3
a719 6
    }
    if (delta <= screen->multiClickTime) {
	CELL cell;

	PointToCELL(screen, event->xbutton.y, event->xbutton.x, &cell);
	if (isSameCELL(&cell, &lastButton3)) {
d722 2
a723 1
	    PointToCELL(screen, event->xbutton.y, event->xbutton.x, &lastButton3);
d734 1
a734 3
rowOnCurrentLine(TScreen * screen,
		 int line,
		 int *deltap)	/* must be XButtonEvent */
d736 1
d757 1
a757 1
eventRow(TScreen * screen, XEvent * event)	/* must be XButtonEvent */
d759 2
d765 1
a765 1
eventColBetween(TScreen * screen, XEvent * event)	/* must be XButtonEvent */
d767 2
d775 1
a775 1
ReadLineMovePoint(TScreen * screen, int col, int ldelta)
d777 1
d781 1
a781 1
    col += ldelta * MaxCols(screen) - screen->cur_col;
d799 1
a799 1
ReadLineDelete(TScreen * screen, CELL * cell1, CELL * cell2)
d801 1
d804 1
a804 1
    del = (cell2->col - cell1->col) + ((cell2->row - cell1->row) * MaxCols(screen));
d808 1
a808 1
	v_write(screen->respond, (Char *) "\177", 1);
d815 1
a815 1
DiredButton(Widget w,
d820 13
a832 16
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
	TScreen *screen = &(xw->screen);
	Char Line[6];
	unsigned line, col;

	if (event->type == ButtonPress || event->type == ButtonRelease) {
	    line = (event->xbutton.y - screen->border) / FontHeight(screen);
	    col = (event->xbutton.x - OriginX(screen)) / FontWidth(screen);
	    Line[0] = CONTROL('X');
	    Line[1] = ESC;
	    Line[2] = 'G';
	    Line[3] = ' ' + col;
	    Line[4] = ' ' + line;
	    v_write(screen->respond, Line, 5);
	}
d838 1
a838 1
ReadLineButton(Widget w,
d843 3
a845 28
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
	TScreen *screen = &(xw->screen);
	Char Line[6];
	int line, col, ldelta = 0;

	if (!(event->type == ButtonPress || event->type == ButtonRelease)
	    || (screen->send_mouse_pos != MOUSE_OFF) || ExtendingSelection)
	    goto finish;
	if (event->type == ButtonRelease) {
	    int delta;

	    if (lastButtonDownTime == (Time) 0) {
		/* first time and once in a blue moon */
		delta = screen->multiClickTime + 1;
	    } else if (event->xbutton.time > lastButtonDownTime) {
		/* most of the time */
		delta = event->xbutton.time - lastButtonDownTime;
	    } else {
		/* time has rolled over since lastButtonUpTime */
		delta = (((Time) ~ 0) - lastButtonDownTime) + event->xbutton.time;
	    }
	    if (delta > screen->multiClickTime)
		goto finish;	/* All this work for this... */
	}
	line = (event->xbutton.y - screen->border) / FontHeight(screen);
	if (line != screen->cur_row) {
	    int l1, l2;
d847 29
a875 28
	    if (line < screen->cur_row)
		l1 = line, l2 = screen->cur_row;
	    else
		l2 = line, l1 = screen->cur_row;
	    l1--;
	    while (++l1 < l2)
		if (!ScrnTstWrapped(screen, l1))
		    goto finish;
	    /* Everything is on one "wrapped line" now */
	    ldelta = line - screen->cur_row;
	}
	/* Correct by half a width - we are acting on a boundary, not on a cell. */
	col = (event->xbutton.x - OriginX(screen) + (FontWidth(screen) - 1)
	       / 2)
	    / FontWidth(screen) - screen->cur_col + ldelta * MaxCols(screen);
	if (col == 0)
	    goto finish;
	Line[0] = ESC;
	/* XXX: sometimes it is better to send '['? */
	Line[1] = 'O';
	Line[2] = (col > 0 ? 'C' : 'D');
	if (col < 0)
	    col = -col;
	while (col--)
	    v_write(screen->respond, Line, 3);
      finish:
	if (event->type == ButtonRelease)
	    do_select_end(xw, event, params, num_params, False);
d877 16
d898 1
a898 1
ViButton(Widget w,
d903 6
a908 14
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
	TScreen *screen = &(xw->screen);
	int pty = screen->respond;
	Char Line[6];
	int line;

	if (event->type == ButtonPress || event->type == ButtonRelease) {

	    line = screen->cur_row -
		((event->xbutton.y - screen->border) / FontHeight(screen));
	    if (line != 0) {
		Line[0] = ESC;	/* force an exit from insert-mode */
		v_write(pty, Line, 1);
d910 11
a920 8
		if (line < 0) {
		    line = -line;
		    Line[0] = CONTROL('n');
		} else {
		    Line[0] = CONTROL('p');
		}
		while (--line >= 0)
		    v_write(pty, Line, 1);
d922 2
d938 16
a953 13
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
	TScreen *screen = &(xw->screen);
	CELL cell;

	screen->selection_time = event->xmotion.time;
	switch (eventMode) {
	    /* If not in one of the DEC mouse-reporting modes */
	case LEFTEXTENSION:
	case RIGHTEXTENSION:
	    PointToCELL(screen, event->xmotion.y, event->xmotion.x, &cell);
	    ExtendExtend(screen, &cell);
	    break;
d955 7
a961 9
	    /* If in motion reporting mode, send mouse position to
	       character process as a key sequence \E[M... */
	case NORMAL:
	    /* will get here if send_mouse_pos != MOUSE_OFF */
	    if (screen->send_mouse_pos == BTN_EVENT_MOUSE
		|| screen->send_mouse_pos == ANY_EVENT_MOUSE) {
		(void) SendMousePosition(xw, event);
	    }
	    break;
d963 1
a963 12
    }
}

void
HandleKeyboardSelectExtend(Widget w,
			   XEvent * event GCC_UNUSED,	/* must be XButtonEvent */
			   String * params GCC_UNUSED,
			   Cardinal *num_params GCC_UNUSED)
{
    if (IsXtermWidget(w)) {
	TScreen *screen = &((XtermWidget) w)->screen;
	ExtendExtend(screen, &screen->cursorp);
d968 1
a968 1
do_select_end(XtermWidget xw,
d976 1
a976 1
    TScreen *screen = &xw->screen;
d979 5
a983 1
    xw->screen.selection_time = event->xbutton.time;
d986 1
a986 1
	(void) SendMousePosition(xw, event);
d990 1
a990 1
	EndExtend(xw, event, params, *num_params, use_cursor_loc);
d992 1
a992 1
	if (isClick1_clean(screen, event)
d994 2
a995 2
	    && rowOnCurrentLine(screen, eventRow(screen, event), &ldelta1)) {
	    ReadLineMovePoint(screen, eventColBetween(screen, event), ldelta1);
d997 1
a997 1
	if (isDoubleClick3(screen, event)
d999 4
a1002 4
	    && rowOnCurrentLine(screen, screen->startSel.row, &ldelta1)
	    && rowOnCurrentLine(screen, screen->endSel.row, &ldelta2)) {
	    ReadLineMovePoint(screen, screen->endSel.col, ldelta2);
	    ReadLineDelete(screen, &screen->startSel, &(screen->endSel));
d1015 1
a1015 2
    if (IsXtermWidget(w))
	do_select_end((XtermWidget) w, event, params, num_params, False);
d1024 1
a1024 2
    if (IsXtermWidget(w))
	do_select_end((XtermWidget) w, event, params, num_params, True);
d1034 3
a1036 3
/*
 * Convert a UTF-8 string to Latin-1, replacing non Latin-1 characters by `#'.
 */
a1136 64
#define isSELECT(value) (!strcmp(value, "SELECT"))

static void
UnmapSelections(XtermWidget xw)
{
    TScreen *screen = &(xw->screen);
    Cardinal n;

    if (screen->mappedSelect) {
	for (n = 0; screen->mappedSelect[n] != 0; ++n)
	    free(screen->mappedSelect[n]);
	free(screen->mappedSelect);
	screen->mappedSelect = 0;
    }
}

/*
 * xterm generally uses the primary selection.  Some applications prefer
 * (or are limited to) the clipboard.  Since the translations resource is
 * complicated, users seldom change the way it affects selection.  But it
 * is simple to remap the choice between primary and clipboard before the
 * call to XmuInternStrings().
 */
static String *
MapSelections(XtermWidget xw, String * params, Cardinal num_params)
{
    String *result = params;

    if (num_params > 0) {
	Cardinal j;
	Boolean map = False;

	for (j = 0; j < num_params; ++j) {
	    TRACE(("param[%d]:%s\n", j, params[j]));
	    if (isSELECT(params[j])) {
		map = True;
		break;
	    }
	}
	if (map) {
	    String mapTo = (xw->screen.selectToClipboard
			    ? "CLIPBOARD"
			    : "PRIMARY");

	    UnmapSelections(xw);
	    if ((result = TypeMallocN(String, num_params + 1)) != 0) {
		result[num_params] = 0;
		for (j = 0; j < num_params; ++j) {
		    result[j] = x_strdup((isSELECT(params[j])
					  ? mapTo
					  : params[j]));
		    if (result[j] == 0) {
			UnmapSelections(xw);
			result = 0;
			break;
		    }
		}
		xw->screen.mappedSelect = result;
	    }
	}
    }
    return result;
}

a1176 1
#if OPT_PASTE64
d1178 5
a1182 19
FinishPaste64(TScreen * screen)
{
    TRACE(("FinishPaste64(%d)\n", screen->base64_paste));
    if (screen->base64_paste) {
	screen->base64_paste = 0;
	unparseputc1(screen->base64_final, screen->respond);
    }
}
#endif

#if !OPT_PASTE64
static
#endif
void
xtermGetSelection(Widget w,
		  Time ev_time,
		  String * params,	/* selections in precedence order */
		  Cardinal num_params,
		  Atom * targets)
d1191 9
a1199 2
    TRACE(("xtermGetSelection\n"));
    params = MapSelections((XtermWidget) w, params, num_params);
a1202 1

a1204 1

a1214 1

d1218 2
a1219 8
	else if (num_params > 1) {
	    xtermGetSelection(w, ev_time, params + 1, num_params - 1, NULL);
	}
#if OPT_PASTE64
	else {
	    FinishPaste64(&(((XtermWidget) w)->screen));
	}
#endif
d1269 3
a1271 9
    TRACE(("Getting %s (%ld)\n", name, (long int) type));
    for (cp = line; cp < line + len; cp++) {
	TRACE(("[%d:%lu]", cp + 1 - line, len));
	if (isprint(*cp)) {
	    TRACE(("%c\n", *cp));
	} else {
	    TRACE(("\\x%02x\n", *cp));
	}
    }
a1282 32
#if OPT_PASTE64
/* Return base64 code character given 6-bit number */
static const char base64_code[] = "\
ABCDEFGHIJKLMNOPQRSTUVWXYZ\
abcdefghijklmnopqrstuvwxyz\
0123456789+/";
static void
base64_flush(TScreen * screen)
{
    Char x;
    switch (screen->base64_count) {
    case 0:
	break;
    case 2:
	x = base64_code[screen->base64_accu << 4];
	tty_vwrite(screen->respond, &x, 1);
	break;
    case 4:
	x = base64_code[screen->base64_accu << 2];
	tty_vwrite(screen->respond, &x, 1);
	break;
    }
    if (screen->base64_pad & 3)
	tty_vwrite(screen->respond,
		   (Char *) "===",
		   (unsigned) (4 - (screen->base64_pad & 3)));
    screen->base64_count = 0;
    screen->base64_accu = 0;
    screen->base64_pad = 0;
}
#endif /* OPT_PASTE64 */

a1285 41
#if OPT_PASTE64
    if (screen->base64_paste) {
	/* Send data as base64 */
	Char *p = lag;
	Char buf[64];
	unsigned x = 0;
	while (length--) {
	    switch (screen->base64_count) {
	    case 0:
		buf[x++] = base64_code[*p >> 2];
		screen->base64_accu = (*p & 0x3);
		screen->base64_count = 2;
		++p;
		break;
	    case 2:
		buf[x++] = base64_code[(screen->base64_accu << 4) + (*p >> 4)];
		screen->base64_accu = (*p & 0xF);
		screen->base64_count = 4;
		++p;
		break;
	    case 4:
		buf[x++] = base64_code[(screen->base64_accu << 2) + (*p >> 6)];
		buf[x++] = base64_code[*p & 0x3F];
		screen->base64_accu = 0;
		screen->base64_count = 0;
		++p;
		break;
	    }
	    if (x >= 63) {
		/* Write 63 or 64 characters */
		screen->base64_pad += x;
		tty_vwrite(screen->respond, buf, x);
		x = 0;
	    }
	}
	if (x != 0) {
	    screen->base64_pad += x;
	    tty_vwrite(screen->respond, buf, x);
	}
    } else
#endif /* OPT_PASTE64 */
d1289 1
a1289 1
	    tty_vwrite(screen->respond, (Char *) "\026", 1);	/* Control-V */
d1304 1
a1304 1
    Char *lag, *end;
d1316 6
a1321 16

#if OPT_PASTE64
    if (screen->base64_paste) {
	_qWriteSelectionData(screen, lag, (unsigned) (end - lag));
	base64_flush(screen);
    } else
#endif
    {
	if (!SCREEN_FLAG(screen, paste_literal_nl)) {
	    Char *cp;
	    for (cp = line; cp != end; cp++) {
		if (*cp == '\n') {
		    *cp = '\r';
		    _qWriteSelectionData(screen, lag, (unsigned) (cp - lag + 1));
		    lag = cp + 1;
		}
d1324 3
a1326 4

	if (lag != end) {
	    _qWriteSelectionData(screen, lag, (unsigned) (end - lag));
	}
d1338 1
a1338 1
    Char line[16];
d1340 1
a1340 1
    unsigned length = strlen((char *) in);
d1365 1
a1365 1
		  int *format)
a1436 5
#if OPT_PASTE64
	if (screen->base64_paste) {
	    ;
	} else
#endif
d1438 2
a1439 3
	if (SCREEN_FLAG(screen, paste_brackets)) {
	    _WriteKey(screen, (Char *) "200");
	}
a1444 5
#if OPT_PASTE64
	if (screen->base64_paste) {
	    FinishPaste64(screen);
	} else
#endif
d1446 2
a1447 3
	if (SCREEN_FLAG(screen, paste_brackets)) {
	    _WriteKey(screen, (Char *) "201");
	}
d1461 2
a1462 2
	xtermGetSelection(w, list->time,
			  list->params, list->count, list->targets);
a1463 4
#if OPT_PASTE64
    } else {
	FinishPaste64(screen);
#endif
d1474 7
a1480 2
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
a1481 1
	if (!SendMousePosition(xw, event)) {
d1483 7
a1489 9
	    int ldelta;
	    TScreen *screen = &(xw->screen);
	    if ((event->type == ButtonPress || event->type == ButtonRelease)
	    /* Disable on Shift-mouse, including the application-mouse modes */
		&& !(KeyModifiers & ShiftMask)
		&& (screen->send_mouse_pos == MOUSE_OFF)
		&& SCREEN_FLAG(screen, paste_moves)
		&& rowOnCurrentLine(screen, eventRow(screen, event), &ldelta))
		ReadLineMovePoint(screen, eventColBetween(screen, event), ldelta);
d1492 1
a1492 3
	    xtermGetSelection(w, event->xbutton.time, params, *num_params, NULL);
	}
    }
d1496 1
a1496 1
EvalSelectUnit(TScreen * screen, Time buttonDownTime, SelectUnit defaultUnit)
a1497 1
    SelectUnit result;
d1500 6
a1505 10
    if (screen->lastButtonUpTime == (Time) 0) {
	/* first time and once in a blue moon */
	delta = screen->multiClickTime + 1;
    } else if (buttonDownTime > screen->lastButtonUpTime) {
	/* most of the time */
	delta = buttonDownTime - screen->lastButtonUpTime;
    } else {
	/* time has rolled over since lastButtonUpTime */
	delta = (((Time) ~ 0) - screen->lastButtonUpTime) + buttonDownTime;
    }
d1507 3
a1509 3
    if (delta > screen->multiClickTime) {
	screen->numberOfClicks = 1;
	result = defaultUnit;
d1511 2
a1512 2
	result = screen->selectMap[screen->numberOfClicks % screen->maxClicks];
	screen->numberOfClicks += 1;
a1513 2
    TRACE(("EvalSelectUnit(%d) = %d\n", screen->numberOfClicks, result));
    return result;
d1517 1
a1517 1
do_select_start(XtermWidget xw,
d1519 2
a1520 1
		CELL * cell)
d1522 1
a1522 3
    TScreen *screen = &(xw->screen);

    if (SendMousePosition(xw, event))
d1524 2
a1525 2
    screen->selectUnit = EvalSelectUnit(screen, event->xbutton.time, Select_CHAR);
    screen->replyToEmacs = False;
d1531 1
a1531 1
    StartSelect(screen, cell);
d1541 10
a1550 8
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
	TScreen *screen = &(xw->screen);
	CELL cell;

	screen->firstValidRow = 0;
	screen->lastValidRow = screen->max_row;
	PointToCELL(screen, event->xbutton.y, event->xbutton.x, &cell);
d1553 1
a1553 1
	ExtendingSelection = 0;
d1556 1
a1556 2
	do_select_start(xw, event, &cell);
    }
d1566 7
a1572 5
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
	TScreen *screen = &(xw->screen);
	do_select_start(xw, event, &screen->cursorp);
    }
d1576 1
a1576 1
TrackDown(TScreen * screen, XButtonEvent * event)
d1578 1
a1578 1
    CELL cell;
d1580 5
a1584 5
    screen->selectUnit = EvalSelectUnit(screen, event->time, Select_CHAR);
    if (screen->numberOfClicks > 1) {
	PointToCELL(screen, event->y, event->x, &cell);
	screen->replyToEmacs = True;
	StartSelect(screen, &cell);
d1586 2
a1587 2
	waitingForTrackInfo = True;
	EditorButton(screen, (XButtonEvent *) event);
d1594 1
a1594 1
			    x = screen->max_row
d1597 1
a1597 5
TrackMouse(TScreen * screen,
	   int func,
	   CELL * start,
	   int firstrow,
	   int lastrow)
d1599 1
a1599 4
    if (waitingForTrackInfo) {	/* if Timed, ignore */
	waitingForTrackInfo = False;
	if (func != 0) {
	    CELL first = *start;
d1601 2
a1602 8
	    boundsCheck(first.row);
	    boundsCheck(firstrow);
	    boundsCheck(lastrow);
	    screen->firstValidRow = firstrow;
	    screen->lastValidRow = lastrow;
	    screen->replyToEmacs = True;
	    StartSelect(screen, &first);
	}
d1604 10
d1617 1
a1617 1
StartSelect(TScreen * screen, const CELL * cell)
d1619 3
a1621 1
    TRACE(("StartSelect row=%d, col=%d\n", cell->row, cell->col));
d1624 1
a1624 1
    if (screen->numberOfClicks == 1) {
d1626 3
a1628 1
	screen->rawPos = *cell;
d1630 6
a1635 4
    /* else use old values in rawPos */
    screen->saveStartR = screen->startExt = screen->rawPos;
    screen->saveEndR = screen->endExt = screen->rawPos;
    if (Coordinate(screen, cell) < Coordinate(screen, &(screen->rawPos))) {
d1637 2
a1638 1
	screen->startExt = *cell;
d1641 2
a1642 1
	screen->endExt = *cell;
d1644 1
a1644 1
    ComputeSelect(screen, &(screen->startExt), &(screen->endExt), False);
d1648 1
a1648 1
EndExtend(XtermWidget xw,
d1654 1
a1654 1
    CELL cell;
d1656 1
a1656 1
    TScreen *screen = &xw->screen;
d1660 2
a1661 1
	cell = screen->cursorp;
d1663 1
a1663 1
	PointToCELL(screen, event->xbutton.y, event->xbutton.x, &cell);
d1665 4
a1668 4
    ExtendExtend(screen, &cell);
    screen->lastButtonUpTime = event->xbutton.time;
    if (!isSameCELL(&(screen->startSel), &(screen->endSel))) {
	if (screen->replyToEmacs) {
d1676 2
a1677 2
	    if (isSameCELL(&(screen->rawPos), &(screen->startSel))
		&& isSameCELL(&cell, &(screen->endSel))) {
d1680 2
a1681 2
		line[count++] = ' ' + screen->endSel.col + 1;
		line[count++] = ' ' + screen->endSel.row + 1;
d1685 6
a1690 6
		line[count++] = ' ' + screen->startSel.col + 1;
		line[count++] = ' ' + screen->startSel.row + 1;
		line[count++] = ' ' + screen->endSel.col + 1;
		line[count++] = ' ' + screen->endSel.row + 1;
		line[count++] = ' ' + cell.col + 1;
		line[count++] = ' ' + cell.row + 1;
d1693 1
a1693 1
	    TrackText(screen, &zeroCELL, &zeroCELL);
d1696 1
a1696 1
    SelectSet(xw, event, params, num_params);
d1706 1
a1706 3
    if (IsXtermWidget(w)) {
	SelectSet((XtermWidget) w, event, params, *num_params);
    }
d1711 1
a1711 1
SelectSet(XtermWidget xw,
a1715 2
    TScreen *screen = &(xw->screen);

d1718 3
a1720 2
    if (!isSameCELL(&(screen->startSel), &(screen->endSel))) {
	SaltTextAway(xw, &(screen->startSel), &(screen->endSel), params, num_params);
d1722 1
a1722 1
	DisownSelection(xw);
d1730 1
a1730 1
do_start_extend(XtermWidget xw,
d1736 2
a1737 3
    TScreen *screen = &(xw->screen);
    int coord;
    CELL cell;
d1739 1
a1739 1
    if (!IsXtermWidget(xw))
d1742 2
a1743 1
    if (SendMousePosition(xw, event))
d1745 2
a1746 3

    screen->firstValidRow = 0;
    screen->lastValidRow = screen->max_row;
d1752 2
a1753 2
	screen->selectUnit = EvalSelectUnit(screen, event->xbutton.time, screen->selectUnit);
    screen->replyToEmacs = False;
d1756 1
a1756 1
    CheckSecondPress3(screen, event);
d1759 1
a1759 1
    if (screen->numberOfClicks == 1
d1764 4
a1767 2
	screen->saveStartR = screen->startExt = screen->startRaw;
	screen->saveEndR = screen->endExt = screen->endRaw;
d1770 5
a1774 2
	screen->startExt = screen->startRaw = screen->saveStartR;
	screen->endExt = screen->endRaw = screen->saveEndR;
d1777 2
a1778 1
	cell = screen->cursorp;
d1780 1
a1780 1
	PointToCELL(screen, event->xbutton.y, event->xbutton.x, &cell);
d1782 1
a1782 1
    coord = Coordinate(screen, &cell);
d1784 3
a1786 3
    if (Abs(coord - Coordinate(screen, &(screen->startSel)))
	< Abs(coord - Coordinate(screen, &(screen->endSel)))
	|| coord < Coordinate(screen, &(screen->startSel))) {
d1789 2
a1790 1
	screen->startExt = cell;
d1794 2
a1795 1
	screen->endExt = cell;
d1797 1
a1797 1
    ComputeSelect(screen, &(screen->startExt), &(screen->endExt), True);
d1800 1
a1800 1
    if (!isSameCELL(&(screen->startSel), &(screen->endSel)))
d1806 1
a1806 1
ExtendExtend(TScreen * screen, const CELL * cell)
d1808 1
a1808 1
    int coord = Coordinate(screen, cell);
d1810 1
a1810 1
    TRACE(("ExtendExtend row=%d, col=%d\n", cell->row, cell->col));
d1812 1
a1812 2
	&& ((coord + (screen->selectUnit != Select_CHAR))
	    > Coordinate(screen, &(screen->endSel)))) {
d1815 2
a1816 1
	screen->startExt = screen->saveStartR;
d1818 1
a1818 1
	       && coord < Coordinate(screen, &(screen->startSel))) {
d1821 2
a1822 1
	screen->endExt = screen->saveEndR;
d1825 2
a1826 1
	screen->startExt = *cell;
d1828 2
a1829 1
	screen->endExt = *cell;
d1831 1
a1831 1
    ComputeSelect(screen, &(screen->startExt), &(screen->endExt), False);
d1834 1
a1834 1
    if (!isSameCELL(&(screen->startSel), &(screen->endSel)))
d1845 1
a1845 2
    if (IsXtermWidget(w))
	do_start_extend((XtermWidget) w, event, params, num_params, False);
d1854 1
a1854 2
    if (IsXtermWidget(w))
	do_start_extend((XtermWidget) w, event, params, num_params, True);
d1860 2
a1861 2
    int minrow = INX2ROW(screen, -screen->savedlines);
    int maxrow = INX2ROW(screen, screen->max_row);
d1864 5
a1868 5
#define scroll_update_one(cell) \
	(cell)->row += amount; \
	if ((cell)->row < minrow) { \
	    (cell)->row = minrow; \
	    (cell)->col = 0; \
d1870 3
a1872 3
	if ((cell)->row > maxrow) { \
	    (cell)->row = maxrow; \
	    (cell)->col = maxcol; \
d1875 4
a1878 4
    scroll_update_one(&(screen->startRaw));
    scroll_update_one(&(screen->endRaw));
    scroll_update_one(&(screen->startSel));
    scroll_update_one(&(screen->endSel));
d1880 1
a1880 1
    scroll_update_one(&(screen->rawPos));
d1892 1
a1892 1
	adjust = ROW2INX(screen, screen->startH.row);
d1896 1
a1896 1
	    scroll_update_one(&screen->startH);
d1898 1
a1898 1
	adjust = ROW2INX(screen, screen->endH.row);
d1902 1
a1902 1
	    scroll_update_one(&screen->endH);
d1906 2
a1907 2
    screen->startHCoord = Coordinate(screen, &screen->startH);
    screen->endHCoord = Coordinate(screen, &screen->endH);
d1917 21
a1937 21
    if (screen->startRaw.row > rows)
	screen->startRaw.row = rows;
    if (screen->startSel.row > rows)
	screen->startSel.row = rows;
    if (screen->endRaw.row > rows)
	screen->endRaw.row = rows;
    if (screen->endSel.row > rows)
	screen->endSel.row = rows;
    if (screen->rawPos.row > rows)
	screen->rawPos.row = rows;

    if (screen->startRaw.col > cols)
	screen->startRaw.col = cols;
    if (screen->startSel.col > cols)
	screen->startSel.col = cols;
    if (screen->endRaw.col > cols)
	screen->endRaw.col = cols;
    if (screen->endSel.col > cols)
	screen->endSel.col = cols;
    if (screen->rawPos.col > cols)
	screen->rawPos.col = cols;
d1951 4
a1954 4
PointToCELL(TScreen * screen,
	    int y,
	    int x,
	    CELL * cell)
d1960 13
a1972 10
    cell->row = (y - screen->border) / FontHeight(screen);
    if (cell->row < screen->firstValidRow)
	cell->row = screen->firstValidRow;
    else if (cell->row > screen->lastValidRow)
	cell->row = screen->lastValidRow;
    cell->col = (x - OriginX(screen)) / FontWidth(screen);
    if (cell->col < 0)
	cell->col = 0;
    else if (cell->col > MaxCols(screen)) {
	cell->col = MaxCols(screen);
d1979 4
a1982 4
    if (cell->col > 0
	&& isWideCell(cell->row, cell->col - 1)
	&& (XTERM_CELL(cell->row, cell->col) == HIDDEN_CHAR)) {
	cell->col -= 1;
d1985 2
a1988 3
/*
 * Find the last column at which text was drawn on the given row.
 */
d1990 1
a1990 1
LastTextCol(TScreen * screen, int row)
d1992 1
a1992 1
    int inx = ROW2INX(screen, row);
d1996 1
a1996 1
    if (inx + screen->savedlines >= 0) {
d1998 1
a1998 1
	     ch = SCRN_BUF_ATTRS(screen, inx) + i;
d2002 1
a2002 1
	if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, inx)[0])) {
d2110 1
a2110 1
class_of(TScreen * screen, CELL * cell)
a2111 1
    CELL temp = *cell;
a2112 1

d2114 2
a2115 2
    if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, ROW2INX(screen, temp.row))[0])) {
	temp.col /= 2;
d2118 1
a2118 2

    value = XTERM_CELL(temp.row, temp.col);
d2124 3
a2126 3
#define ClassSelects(screen, cell, cclass) \
	 (class_of(screen, cell) == cclass \
	 || XTERM_CELL((cell)->row, (cell)->col) == HIDDEN_CHAR)
d2128 3
a2130 3
#define class_of(screen, cell) charClass[XTERM_CELL((cell)->row, (cell)->col)]
#define ClassSelects(screen, cell, cclass) \
	 (class_of(screen, (cell)) == cclass)
d2134 1
a2134 263
 * If the given column is past the end of text on the given row, bump to the
 * beginning of the next line.
 */
static Boolean
okPosition(TScreen * screen,
	   CELL * cell)
{
    if (cell->col > (LastTextCol(screen, cell->row) + 1)) {
	cell->col = 0;
	cell->row += 1;
	return False;
    }
    return True;
}

static void
trimLastLine(TScreen * screen, CELL * last)
{
    if (screen->cutNewline) {
	last->col = 0;
	++last->row;
    } else {
	last->col = LastTextCol(screen, last->row) + 1;
    }
}

#if OPT_SELECT_REGEX
/*
 * Returns the first row of a wrapped line.
 */
static int
firstRowOfLine(TScreen * screen, int row, Bool visible)
{
    int limit = visible ? 0 : -screen->savedlines;

    while (row > limit &&
	   ScrnTstWrapped(screen, row - 1))
	--row;
    return row;
}

/*
 * Returns the last row of a wrapped line.
 */
static int
lastRowOfLine(TScreen * screen, int row)
{
    while (row < screen->max_row &&
	   ScrnTstWrapped(screen, row))
	++row;
    return row;
}

/*
 * Returns the number of cells on the range of rows.
 */
static unsigned
lengthOfLines(TScreen * screen, int firstRow, int lastRow)
{
    unsigned length = 0;
    int n;

    for (n = firstRow; n <= lastRow; ++n) {
	int value = LastTextCol(screen, n);
	if (value >= 0)
	    length += (value + 1);
    }
    return length;
}

/*
 * Make a copy of the wrapped-line which corresponds to the given row as a
 * string of bytes.  Construct an index for the columns from the beginning of
 * the line.
 */
static char *
make_indexed_text(TScreen * screen, int row, unsigned length, int *indexed)
{
    Char *result = 0;
    unsigned need = (length + 1);

    /*
     * Get a quick upper bound to the number of bytes needed, if the whole
     * string were UTF-8.
     */
    if_OPT_WIDE_CHARS(screen, {
	need *= (MAX_PTRS * 6);
    });

    if ((result = TypeCallocN(Char, need + 1)) != 0) {
	unsigned used = 0;
	Char *last = result;

	do {
	    int col = 0;
	    int limit = LastTextCol(screen, row);

	    while (col <= limit) {
		Char *next = last;
		unsigned data = XTERM_CELL(row, col);

		/* some internal points may not be drawn */
		if (data == 0)
		    data = ' ';
#if OPT_WIDE_CHARS
		next = convertToUTF8(last, data);
#else
		*next++ = CharOf(data);
#endif

		if_OPT_WIDE_CHARS(screen, {
		    if ((data = XTERM_CELL_C1(row, col)) != 0)
			next = convertToUTF8(next, data);
		    if ((data = XTERM_CELL_C2(row, col)) != 0)
			next = convertToUTF8(next, data);
		});

		indexed[used] = last - result;
		*next = 0;
		/* TRACE(("index[%d.%d] %d:%s\n", row, used, indexed[used], last)); */
		last = next;
		++used;
		++col;
		indexed[used] = next - result;
	    }
	} while (used < length &&
		 ScrnTstWrapped(screen, row) &&
		 ++row < screen->max_row);
    }
    /* TRACE(("result:%s\n", result)); */
    return (char *) result;
}

/*
 * Find the column given an offset into the character string by using the
 * index constructed in make_indexed_text().
 */
static int
indexToCol(int *indexed, int len, int off)
{
    int col = 0;
    while (indexed[col] < len) {
	if (indexed[col] >= off)
	    break;
	++col;
    }
    return col;
}

/*
 * Given a row number, and a column offset from that (which may be wrapped),
 * set the cell to the actual row/column values.
 */
static void
columnToCell(TScreen * screen, int row, int col, CELL * cell)
{
    while (row < screen->max_row) {
	int last = LastTextCol(screen, row);

	/* TRACE(("last(%d) = %d, have %d\n", row, last, col)); */
	if (col <= last) {
	    break;
	}
	col -= (last + 1);
	++row;
    }
    if (col < 0)
	col = 0;
    cell->row = row;
    cell->col = col;
}

/*
 * Given a cell, find the corresponding column offset.
 */
static int
cellToColumn(TScreen * screen, CELL * cell)
{
    int col = cell->col;
    int row = firstRowOfLine(screen, cell->row, False);
    while (row < cell->row) {
	col += LastTextCol(screen, row++);
    }
    return col;
}

static void
do_select_regex(TScreen * screen, CELL * startc, CELL * endc)
{
    char *expr = screen->selectExpr[screen->numberOfClicks - 1];
    regex_t preg;
    regmatch_t match;
    char *search;
    int *indexed;

    TRACE(("Select_REGEX:%s\n", NonNull(expr)));
    if (okPosition(screen, startc) && expr != 0) {
	if (regcomp(&preg, expr, REG_EXTENDED) == 0) {
	    int firstRow = firstRowOfLine(screen, startc->row, True);
	    int lastRow = lastRowOfLine(screen, firstRow);
	    unsigned size = lengthOfLines(screen, firstRow, lastRow);
	    int actual = cellToColumn(screen, startc);

	    TRACE(("regcomp ok rows %d..%d bytes %d\n",
		   firstRow, lastRow, size));

	    if ((indexed = TypeCallocN(int, size + 1)) != 0) {
		if ((search = make_indexed_text(screen,
						firstRow,
						size,
						indexed)) != 0) {
		    int len = strlen(search);
		    int col;
		    int best_col = -1;
		    int best_len = -1;

		    for (col = 0; indexed[col] < len; ++col) {
			if (regexec(&preg,
				    search + indexed[col],
				    1, &match, 0) == 0) {
			    int start_inx = match.rm_so + indexed[col];
			    int finis_inx = match.rm_eo + indexed[col];
			    int start_col = indexToCol(indexed, len, start_inx);
			    int finis_col = indexToCol(indexed, len, finis_inx);

			    if (start_col <= actual &&
				actual < finis_col) {
				int test = finis_col - start_col;
				if (best_len < test) {
				    best_len = test;
				    best_col = start_col;
				    TRACE(("match column %d len %d\n",
					   best_col,
					   best_len));
				}
			    }
			}
		    }
		    if (best_col >= 0) {
			columnToCell(screen, firstRow, best_col, startc);
			columnToCell(screen, firstRow, best_col + best_len, endc);
			TRACE(("search::%s\n", search));
			TRACE(("indexed:%d..%d -> %d..%d\n",
			       best_col, best_col + best_len,
			       indexed[best_col],
			       indexed[best_col + best_len]));
			TRACE(("matched:%.*s\n",
			       indexed[best_col + best_len] + 1 -
			       indexed[best_col],
			       search + indexed[best_col]));
		    }
		    free(search);
		}
		free(indexed);
	    }
	    regfree(&preg);
	}
    }
}
#endif /* OPT_SELECT_REGEX */

/*
 * sets startSel endSel
d2138 4
a2141 3
ComputeSelect(TScreen * screen,
	      CELL * startc,
	      CELL * endc,
d2144 1
a2146 2
    CELL first = *startc;
    CELL last = *endc;
d2149 1
a2149 3
	   first.row, first.col,
	   last.row, last.col,
	   extend ? "" : "no"));
d2152 13
a2164 13
    if (first.col > 1
	&& isWideCell(first.row, first.col - 1)
	&& XTERM_CELL(first.row, first.col - 0) == HIDDEN_CHAR) {
	fprintf(stderr, "Adjusting start. Changing downwards from %i.\n", first.col);
	first.col -= 1;
	if (last.col == (first.col + 1))
	    last.col--;
    }

    if (last.col > 1
	&& isWideCell(last.row, last.col - 1)
	&& XTERM_CELL(last.row, last.col) == HIDDEN_CHAR) {
	last.col += 1;
d2168 5
a2172 3
    if (Coordinate(screen, &first) <= Coordinate(screen, &last)) {
	screen->startSel = screen->startRaw = first;
	screen->endSel = screen->endRaw = last;
d2174 23
a2196 14
	screen->startSel = screen->startRaw = last;
	screen->endSel = screen->endRaw = first;
    }

    switch (screen->selectUnit) {
    case Select_CHAR:
	(void) okPosition(screen, &(screen->startSel));
	(void) okPosition(screen, &(screen->endSel));
	break;

    case Select_WORD:
	TRACE(("Select_WORD\n"));
	if (okPosition(screen, &(screen->startSel))) {
	    cclass = class_of(screen, &(screen->startSel));
d2198 5
a2202 6
		--screen->startSel.col;
		if (screen->startSel.row > 0
		    && screen->startSel.col < 0
		    && ScrnTstWrapped(screen, screen->startSel.row - 1)) {
		    --screen->startSel.row;
		    screen->startSel.col = LastTextCol(screen, screen->startSel.row);
d2204 3
a2206 3
	    } while (screen->startSel.col >= 0
		     && ClassSelects(screen, &(screen->startSel), cclass));
	    ++screen->startSel.col;
d2208 1
d2210 2
a2211 4
	if (screen->startSel.col
	    && XTERM_CELL(screen->startSel.row,
			  screen->startSel.col) == HIDDEN_CHAR)
	    screen->startSel.col++;
d2214 6
a2219 3
	if (okPosition(screen, &(screen->endSel))) {
	    length = LastTextCol(screen, screen->endSel.row);
	    cclass = class_of(screen, &(screen->endSel));
d2221 6
a2226 6
		++screen->endSel.col;
		if (screen->endSel.col > length
		    && ScrnTstWrapped(screen, screen->endSel.row)) {
		    screen->endSel.col = 0;
		    ++screen->endSel.row;
		    length = LastTextCol(screen, screen->endSel.row);
d2228 9
a2236 9
	    } while (screen->endSel.col <= length
		     && ClassSelects(screen, &(screen->endSel), cclass));
	    /* Word-select selects if pointing to any char in "word",
	     * especially note that it includes the last character in a word.
	     * So we do no --endSel.col and do special eol handling.
	     */
	    if (screen->endSel.col > length + 1) {
		screen->endSel.col = 0;
		++screen->endSel.row;
d2239 1
d2241 2
a2242 4
	if (screen->endSel.col
	    && XTERM_CELL(screen->endSel.row,
			  screen->endSel.col) == HIDDEN_CHAR)
	    screen->endSel.col++;
d2245 2
a2246 1
	screen->saveStartW = screen->startSel;
d2248 9
a2256 12

    case Select_LINE:
	TRACE(("Select_LINE\n"));
	while (ScrnTstWrapped(screen, screen->endSel.row)) {
	    ++screen->endSel.row;
	}
	if (screen->cutToBeginningOfLine
	    || screen->startSel.row < screen->saveStartW.row) {
	    screen->startSel.col = 0;
	    while (screen->startSel.row > 0
		   && ScrnTstWrapped(screen, screen->startSel.row - 1)) {
		--screen->startSel.row;
d2259 6
a2264 7
	    if ((first.row < screen->saveStartW.row)
		|| (isSameRow(&first, &(screen->saveStartW))
		    && first.col < screen->saveStartW.col)) {
		screen->startSel.col = 0;
		while (screen->startSel.row > 0
		       && ScrnTstWrapped(screen, screen->startSel.row - 1)) {
		    --screen->startSel.row;
d2267 2
a2268 1
		screen->startSel = screen->saveStartW;
d2271 5
a2275 20
	trimLastLine(screen, &(screen->endSel));
	break;

    case Select_GROUP:		/* paragraph */
	TRACE(("Select_GROUP\n"));
	if (okPosition(screen, &(screen->startSel))) {
	    /* scan backward for beginning of group */
	    while (screen->startSel.row > 0 &&
		   (LastTextCol(screen, screen->startSel.row - 1) > 0 ||
		    ScrnTstWrapped(screen, screen->startSel.row - 1))) {
		--screen->startSel.row;
	    }
	    screen->startSel.col = 0;
	    /* scan forward for end of group */
	    while (screen->endSel.row < screen->max_row &&
		   (LastTextCol(screen, screen->endSel.row + 1) > 0 ||
		    ScrnTstWrapped(screen, screen->endSel.row))) {
		++screen->endSel.row;
	    }
	    trimLastLine(screen, &(screen->endSel));
a2277 25

    case Select_PAGE:		/* everything one can see */
	TRACE(("Select_PAGE\n"));
	screen->startSel.row = 0;
	screen->startSel.col = 0;
	screen->endSel.row = screen->max_row + 1;
	screen->endSel.col = 0;
	break;

    case Select_ALL:		/* counts scrollback if in normal screen */
	TRACE(("Select_ALL\n"));
	screen->startSel.row = -screen->savedlines;
	screen->startSel.col = 0;
	screen->endSel.row = screen->max_row + 1;
	screen->endSel.col = 0;
	break;

#if OPT_SELECT_REGEX
    case Select_REGEX:
	do_select_regex(screen, &(screen->startSel), &(screen->endSel));
	break;
#endif

    case NSELECTUNITS:		/* always ignore */
	return;
d2283 1
a2283 1
    TrackText(screen, &(screen->startSel), &(screen->endSel));
d2287 6
a2292 5
/* Guaranteed (first.row, first.col) <= (last.row, last.col) */
static void
TrackText(TScreen * screen,
	  const CELL * firstp,
	  const CELL * lastp)
d2295 19
a2313 16
    CELL old_start, old_end;
    CELL first = *firstp;
    CELL last = *lastp;

    TRACE(("TrackText(first=%d,%d, last=%d,%d)\n",
	   first.row, first.col, last.row, last.col));

    old_start = screen->startH;
    old_end = screen->endH;
    if (isSameCELL(&first, &old_start) &&
	isSameCELL(&last, &old_end))
	return;
    screen->startH = first;
    screen->endH = last;
    from = Coordinate(screen, &screen->startH);
    to = Coordinate(screen, &screen->endH);
d2316 2
a2317 2
	ReHiliteText(screen, &old_start, &old_end);
	ReHiliteText(screen, &first, &last);
d2321 1
a2321 1
	    ReHiliteText(screen, &first, &old_start);
d2324 1
a2324 1
	    ReHiliteText(screen, &old_start, &first);
d2328 1
a2328 1
	    ReHiliteText(screen, &old_end, &last);
d2331 1
a2331 1
	    ReHiliteText(screen, &last, &old_end);
a2337 1
/* Guaranteed that (first->row, first->col) <= (last->row, last->col) */
d2339 5
a2343 3
ReHiliteText(TScreen * screen,
	     CELL * firstp,
	     CELL * lastp)
d2345 1
a2346 2
    CELL first = *firstp;
    CELL last = *lastp;
d2348 1
a2348 2
    TRACE(("ReHiliteText from %d.%d to %d.%d\n",
	   first.row, first.col, last.row, last.col));
d2350 10
a2359 10
    if (first.row < 0)
	first.row = first.col = 0;
    else if (first.row > screen->max_row)
	return;			/* nothing to do, since last.row >= first.row */

    if (last.row < 0)
	return;			/* nothing to do, since first.row <= last.row */
    else if (last.row > screen->max_row) {
	last.row = screen->max_row;
	last.col = MaxCols(screen);
d2361 1
a2361 1
    if (isSameCELL(&first, &last))
d2364 3
a2366 3
    if (!isSameRow(&first, &last)) {	/* do multiple rows */
	if ((i = screen->max_col - first.col + 1) > 0) {	/* first row */
	    ScrnRefresh(screen, first.row, first.col, 1, i, True);
d2368 2
a2369 2
	if ((i = last.row - first.row - 1) > 0) {	/* middle rows */
	    ScrnRefresh(screen, first.row + 1, 0, i, MaxCols(screen), True);
d2371 2
a2372 2
	if (last.col > 0 && last.row <= screen->max_row) {	/* last row */
	    ScrnRefresh(screen, last.row, 0, 1, last.col, True);
d2375 1
a2375 1
	ScrnRefresh(screen, first.row, first.col, 1, last.col - first.col, True);
a2378 4
/*
 * Guaranteed that (cellc->row, cellc->col) <= (cell->row, cell->col), and that both points are valid
 * (may have cell->row = screen->max_row+1, cell->col = 0).
 */
d2380 1
a2380 3
SaltTextAway(XtermWidget xw,
	     CELL * cellc,
	     CELL * cell,
d2383 2
d2386 1
a2386 1
    TScreen *screen = &(xw->screen);
a2390 2
    CELL first = *cellc;
    CELL last = *cell;
d2392 4
a2395 4
    if (isSameRow(&first, &last) && first.col > last.col) {
	int tmp = first.col;
	first.col = last.col;
	last.col = tmp;
d2398 1
a2398 1
    --last.col;
d2401 2
a2402 2
    if (isSameRow(&last, &first)) {
	j = Length(screen, first.row, first.col, last.col);
d2404 2
a2405 2
	j += Length(screen, first.row, first.col, screen->max_col) + 1;
	for (i = first.row + 1; i < last.row; i++)
d2407 2
a2408 2
	if (last.col >= 0)
	    j += Length(screen, last.row, 0, last.col);
d2434 2
a2435 2
    if (isSameRow(&last, &first)) {
	lp = SaveText(screen, last.row, first.col, last.col, lp, &eol);
d2437 1
a2437 1
	lp = SaveText(screen, first.row, first.col, screen->max_col, lp, &eol);
d2440 1
a2440 1
	for (i = first.row + 1; i < last.row; i++) {
d2445 2
a2446 2
	if (last.col >= 0)
	    lp = SaveText(screen, last.row, 0, last.col, lp, &eol);
d2452 1
a2452 9
    _OwnSelection(xw, params, num_params);
}

#if OPT_PASTE64
void
ClearSelectionBuffer(TScreen * screen)
{
    screen->selection_length = 0;
    screen->base64_count = 0;
a2454 88
static void
AppendStrToSelectionBuffer(TScreen * screen, Char * text, unsigned len)
{
    if (len != 0) {
	int j = screen->selection_length + len;		/* New length */
	int k = j + (j >> 2) + 80;	/* New size if we grow buffer: grow by ~50% */
	if (j + 1 >= screen->selection_size) {
	    if (!screen->selection_length) {
		/* New buffer */
		Char *line;
		if ((line = (Char *) malloc((unsigned) k)) == 0)
		    SysError(ERROR_BMALLOC2);
		XtFree((char *) screen->selection_data);
		screen->selection_data = line;
	    } else {
		/* Realloc buffer */
		screen->selection_data = (Char *)
		    realloc(screen->selection_data,
			    (unsigned) k);
		if (screen->selection_data == 0)
		    SysError(ERROR_BMALLOC2);
	    }
	    screen->selection_size = k;
	}
	memcpy(screen->selection_data + screen->selection_length, text, len);
	screen->selection_length += len;
	screen->selection_data[screen->selection_length] = 0;
    }
}

void
AppendToSelectionBuffer(TScreen * screen, unsigned c)
{
    int six;
    Char ch;

    /* Decode base64 character */
    if (c >= 'A' && c <= 'Z')
	six = c - 'A';
    else if (c >= 'a' && c <= 'z')
	six = c - 'a' + 26;
    else if (c >= '0' && c <= '9')
	six = c - '0' + 52;
    else if (c == '+')
	six = 62;
    else if (c == '/')
	six = 63;
    else
	return;

    /* Accumulate bytes */
    switch (screen->base64_count) {
    case 0:
	screen->base64_accu = six;
	screen->base64_count = 6;
	break;

    case 2:
	ch = (screen->base64_accu << 6) + six;
	screen->base64_count = 0;
	AppendStrToSelectionBuffer(screen, &ch, 1);
	break;

    case 4:
	ch = (screen->base64_accu << 4) + (six >> 2);
	screen->base64_accu = (six & 0x3);
	screen->base64_count = 2;
	AppendStrToSelectionBuffer(screen, &ch, 1);
	break;

    case 6:
	ch = (screen->base64_accu << 2) + (six >> 4);
	screen->base64_accu = (six & 0xF);
	screen->base64_count = 4;
	AppendStrToSelectionBuffer(screen, &ch, 1);
	break;
    }
}

void
CompleteSelection(XtermWidget xw, char **args, Cardinal len)
{
    xw->screen.base64_count = 0;
    xw->screen.base64_accu = 0;
    _OwnSelection(xw, args, len);
}
#endif /* OPT_PASTE64 */

d2457 2
a2458 4
			Atom * type,
			XtPointer *value,
			unsigned long *length,
			int *format,
d2465 18
a2482 16
    if (IsXtermWidget(w)) {
	Display *d = XtDisplay(w);
	TScreen *screen = &((XtermWidget) w)->screen;
	XTextProperty textprop;

	if (conversion_function(d, (char **) &screen->selection_data, 1,
				conversion_style,
				&textprop) >= Success) {
	    *value = (XtPointer) textprop.value;
	    *length = textprop.nitems;
	    *type = textprop.encoding;
	    *format = textprop.format;
	    return True;
	}
    }
    return False;
a2510 2

	TRACE(("ConvertSelection XA_TARGETS(d)\n"));
a2540 1
	TRACE(("ConvertSelection XA_STRING - wide\n"));
a2546 1
	TRACE(("ConvertSelection XA_UTF8_STRING(d) - wide\n"));
a2552 1
	TRACE(("ConvertSelection XA_TEXT(d) - wide\n"));
a2558 1
	TRACE(("ConvertSelection XA_COMPOUND_TEXT(d) - wide\n"));
a2573 1
	TRACE(("ConvertSelection XA_STRING\n"));
a2579 1
	TRACE(("ConvertSelection XA_TEXT(d)\n"));
a2585 1
	TRACE(("ConvertSelection XA_COMPOUND_TEXT(d)\n"));
a2593 1
	TRACE(("ConvertSelection XA_UTF8_STRING(d)\n"));
a2601 1
	TRACE(("ConvertSelection XA_LIST_LENGTH(d)\n"));
a2613 1
	TRACE(("ConvertSelection XA_LENGTH(d)\n"));
a2629 1
	TRACE(("ConvertSelection XmuConvertStandardSelection\n"));
d2671 1
a2671 1
	TrackText(screen, &zeroCELL, &zeroCELL);
d2684 1
a2684 1
_OwnSelection(XtermWidget xw,
d2688 1
a2688 2
    TScreen *screen = &(xw->screen);
    Atom *atoms = screen->selection_atoms;
d2692 1
a2692 1
    if (screen->selection_length < 0)
d2695 1
a2695 4
    TRACE(("_OwnSelection\n"));
    selections = MapSelections(xw, selections, count);

    if (count > screen->sel_atoms_size) {
d2698 2
a2699 2
	screen->selection_atoms = atoms;
	screen->sel_atoms_size = count;
d2701 1
a2701 1
    XmuInternStrings(XtDisplay((Widget) xw), selections, count, atoms);
d2705 2
a2706 2
	    if (screen->selection_length >
		4 * XMaxRequestSize(XtDisplay((Widget) xw)) - 32) {
d2709 1
a2709 1
			xterm_name, screen->selection_length, cutbuffer);
d2716 3
a2718 3
		unsigned long length = screen->selection_length;
		Char *data = screen->selection_data;
		if_OPT_WIDE_CHARS((screen), {
d2722 1
a2722 1
		XStoreBuffer(XtDisplay((Widget) xw),
d2727 1
a2727 1
	} else if (!screen->replyToEmacs) {
d2729 2
a2730 2
		XtOwnSelection((Widget) xw, atoms[i],
			       screen->selection_time,
d2734 2
a2735 2
    if (!screen->replyToEmacs)
	screen->selection_count = count;
d2737 1
a2737 1
	TrackText(screen, &zeroCELL, &zeroCELL);
d2744 2
a2745 2
    screen->startH = zeroCELL;
    screen->endH = zeroCELL;
d2749 1
a2749 1
DisownSelection(XtermWidget xw)
d2751 1
a2751 1
    TScreen *screen = &(xw->screen);
d2758 4
a2761 4
	   screen->startH.row,
	   screen->startH.col,
	   screen->endH.row,
	   screen->endH.col));
d2766 1
a2766 1
	    XtDisownSelection((Widget) xw, atoms[i],
d2776 4
a2779 2
	CELL first = screen->startH;
	CELL last = screen->endH;
d2782 1
a2782 1
	ReHiliteText(screen, &first, &last);
d2796 1
a2796 1
    int lastcol = LastTextCol(screen, row);
d2823 1
a2823 1
    if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, ROW2INX(screen, row))[0])) {
d2832 1
a2832 1
	if (screen->utf8_mode != uFalse) {
d2852 1
a2852 1
	if (screen->utf8_mode != uFalse) {
a2887 12
/* 32 + following 7-bit word:

   1:0  Button no: 0, 1, 2.  3=release.
     2  shift
     3  meta
     4  ctrl
     5  set for motion notify
     6  set for wheel
*/

/* Position: 32 - 255. */

d2908 1
a2908 1
EditorButton(TScreen * screen, XButtonEvent * event)
d2910 1
d3026 18
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
