head	1.6;
access;
symbols
	MIRBSD_10_BASE:1.4
	MIRBSD_9_BASE:1.4
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.6
date	2011.10.11.19.37.24;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004E949B0A17D9CA8F;

1.5
date	2011.10.11.19.33.52;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004E949A304D0AB79F;

1.4
date	2006.06.15.19.18.45;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004491B2706C2443B2;

1.3
date	2005.12.17.05.46.05;	author tg;	state Exp;
branches;
next	1.2;
commitid	10043A3A3E65E20A413;

1.2
date	2005.04.14.18.06.24;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.18.10.47.49;	author tg;	state Exp;
branches
	1.1.103.1;
next	;

1.1.103.1
date	2005.03.18.10.47.49;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@oh, wellâ€¦
@
text
@/**	$XFree86$ */
/**	$MirOS: X11/xc/lib/font/fontfile/decompress.c,v 1.5 2011/10/11 19:33:52 tg Exp $ */
/**	_MirOS: src/usr.bin/compress/zopen.c,v 1.10 2011/10/11 19:25:29 tg Exp $ */
/*	$OpenBSD: zopen.c,v 1.17 2005/08/25 17:07:56 millert Exp $	*/
/*	$NetBSD: zopen.c,v 1.5 1995/03/26 09:44:53 glass Exp $	*/

/*-
 * Copyright (c) 2005, 2006, 2011
 *	Thorsten Glaser <tg@@mirbsd.de>
 * Copyright (c) 1985, 1986, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Diomidis Spinellis and James A. Woods, derived from original
 * work by Spencer Thomas and Joseph Orost.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
 * express, or implied, to the maximum extent permitted by applicable
 * law, without malicious intent or gross negligence; in no event may
 * licensor, an author or contributor be held liable for any indirect
 * or other damage, or direct damage except proven a consequence of a
 * direct error of said person and intended use of this work, loss or
 * other issues arising in any way out of its use, even if advised of
 * the possibility of such damage or existence of a nontrivial bug.
 *
 *	From: @@(#)zopen.c	8.1 (Berkeley) 6/27/93
 */

/*-
 * fcompress.c - File compression ala IEEE Computer, June 1984.
 *
 * Compress authors:
 *		Spencer W. Thomas	(decvax!utah-cs!thomas)
 *		Jim McKie		(decvax!mcvax!jim)
 *		Steve Davies		(decvax!vax135!petsd!peora!srd)
 *		Ken Turkowski		(decvax!decwrl!turtlevax!ken)
 *		James A. Woods		(decvax!ihnp4!ames!jaw)
 *		Joe Orost		(decvax!vax135!petsd!joe)
 *
 * Cleaned up and converted to library returning I/O streams by
 * Diomidis Spinellis <dds@@doc.ic.ac.uk>.
 * Converted to the libXfont interface by Thorsten Glaser, with
 * the X Consortium's implementation only used as interface spec.
 *
 * zopen(filename, bits)
 *	Returns a FILE * that can be used for read. On
 *	reading the file is decompressed.
 *	Any file produced by compress(1) can be read.
 */

#include "fontmisc.h"
#include <bufio.h>

#ifndef MIN
#define	MIN(a, b)	(((a) < (b)) ? (a) : (b))
#endif

#ifndef __RCSID
#define __RCSID(x)	static const char __rcsid[] = x
#endif

__RCSID("$MirOS: X11/xc/lib/font/fontfile/decompress.c,v 1.5 2011/10/11 19:33:52 tg Exp $");

#define	BITS		16		/* Default bits. */
#define	HSIZE		69001		/* 95% occupancy */
#define	ZBUFSIZ		8192		/* I/O buffer size */

/* A code_int must be able to hold 2**BITS values of type int, and also -1. */
typedef long code_int;
typedef long count_int;

static const u_char z_magic[] =
	{'\037', '\235'};		/* 1F 9D */

#define	BIT_MASK	0x1f		/* Defines for third byte of header. */
#define	BLOCK_MASK	0x80

/*
 * Masks 0x40 and 0x20 are free.  I think 0x20 should mean that there is
 * a fourth header byte (for expansion).
 */
#define	INIT_BITS 9			/* Initial number of bits/code. */

#define	MAXCODE(n_bits)	((1 << (n_bits)) - 1)

struct s_zstate {
	BufFilePtr zs_file;		/* File stream for I/O */
	enum {
		S_START, S_MIDDLE, S_EOF
	} zs_state;			/* State of computation */
	int zs_n_bits;			/* Number of bits/code. */
	int zs_maxbits;			/* User settable max # bits/code. */
	code_int zs_maxcode;		/* Maximum code, given n_bits. */
	code_int zs_maxmaxcode;		/* Should NEVER generate this code. */
	count_int zs_htab[HSIZE];
	u_short zs_codetab[HSIZE];
	code_int zs_hsize;		/* For dynamic table sizing. */
	code_int zs_free_ent;		/* First unused entry. */
	/*
	 * Block compression parameters -- after all codes are used up,
	 * and compression rate changes, start over.
	 */
	int zs_block_compress;
	int zs_clear_flg;
	long zs_ratio;
	count_int zs_checkpoint;
	long zs_in_count;		/* Length of input. */
	long zs_bytes_out;		/* Length of output. */
	long zs_out_count;		/* # of codes output (for debugging).*/
	u_char zs_buf[ZBUFSIZ];		/* I/O buffer */
	u_char *zs_bp;			/* Current I/O window in the zs_buf */
	int zs_offset;			/* Number of bits in the zs_buf */
	union {
		struct {
			long zs_fcode;
			code_int zs_ent;
			code_int zs_hsize_reg;
			int zs_hshift;
		} w;			/* Write parameters */
		struct {
			u_char *zs_stackp, *zs_ebp;
			int zs_finchar;
			code_int zs_code, zs_oldcode, zs_incode;
			int zs_size;
		} r;			/* Read parameters */
	} u;
};

/* Definitions to retain old variable names */
#define zs_fcode	u.w.zs_fcode
#define zs_ent		u.w.zs_ent
#define zs_hsize_reg	u.w.zs_hsize_reg
#define zs_hshift	u.w.zs_hshift
#define zs_stackp	u.r.zs_stackp
#define zs_finchar	u.r.zs_finchar
#define zs_code		u.r.zs_code
#define zs_oldcode	u.r.zs_oldcode
#define zs_incode	u.r.zs_incode
#define zs_size		u.r.zs_size
#define zs_ebp		u.r.zs_ebp

/*
 * To save much memory, we overlay the table used by compress() with those
 * used by decompress().  The tab_prefix table is the same size and type as
 * the codetab.  The tab_suffix table needs 2**BITS characters.  We get this
 * from the beginning of htab.  The output stack uses the rest of htab, and
 * contains characters.  There is plenty of room for any possible stack
 * (stack used to be 8000 characters).
 */

#define	htabof(i)	zs->zs_htab[i]
#define	codetabof(i)	zs->zs_codetab[i]

#define	tab_prefixof(i)	codetabof(i)
#define	tab_suffixof(i)	((u_char *)(zs->zs_htab))[i]
#define	de_stack	((u_char *)&tab_suffixof(1 << BITS))

#define	CHECK_GAP 10000		/* Ratio check interval. */

/*
 * the next two codes should not be changed lightly, as they must not
 * lie within the contiguous general code space.
 */
#define	FIRST	257		/* First free entry. */
#define	CLEAR	256		/* Table clear output code. */

static int zclose(BufFilePtr, int);
static int zskip(BufFilePtr, int);
static int zread(BufFilePtr);
static code_int	getcode(struct s_zstate *);

/*-
 * Algorithm from "A Technique for High Performance Data Compression",
 * Terry A. Welch, IEEE Computer Vol 17, No 6 (June 1984), pp 8-19.
 *
 * Algorithm:
 *	Modified Lempel-Ziv method (LZW).  Basically finds common
 * substrings and replaces them with a variable size code.  This is
 * deterministic, and can be done on the fly.  Thus, the decompression
 * procedure needs no input table, but tracks the way the table was built.
 */

static int
zclose(BufFilePtr zsf, int doClose)
{
	struct s_zstate *zs;
	BufFilePtr f;

	if (zsf == NULL)
		return (0);

	zs = (struct s_zstate *)zsf->private;

	if (zs == NULL)
		return (0);

	f = zs->zs_file;
	xfree(zs);

	BufFileClose(f, doClose);
	return (1);
}

static int
zskip(BufFilePtr zsf, int len)
{
	code_int gcode;

	while (len--)
		if ((gcode = BufFileGet(zsf)) == BUFFILEEOF)
			return (BUFFILEEOF);
	return (0);
}

static const u_char rmask[9] =
	{0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff};

/*
 * Decompress read.  This routine adapts to the codes in the file building
 * the "string" table on-the-fly; requiring no table to be stored in the
 * compressed file.  See the definitions above.
 */
static int
zread(BufFilePtr zsf)
{
	u_int count = BUFFILESIZE;
	struct s_zstate *zs;
	u_char *bp;

	if (zsf == NULL)
		return (BUFFILEEOF);
	bp = zsf->buffer;
	zs = (struct s_zstate *)zsf->private;
	if ((zs == NULL) || (bp == NULL))
		return (BUFFILEEOF);

	switch (zs->zs_state) {
	case S_START:
		zs->zs_state = S_MIDDLE;
		break;
	case S_MIDDLE:
		goto middle;
	case S_EOF:
		goto eof;
	}

	/* As above, initialize the first 256 entries in the table. */
	zs->zs_maxcode = MAXCODE(zs->zs_n_bits = INIT_BITS);
	for (zs->zs_code = 255; zs->zs_code >= 0; zs->zs_code--) {
		tab_prefixof(zs->zs_code) = 0;
		tab_suffixof(zs->zs_code) = (u_char) zs->zs_code;
	}
	zs->zs_free_ent = zs->zs_block_compress ? FIRST : 256;

	zs->zs_finchar = zs->zs_oldcode = getcode(zs);
	if (zs->zs_oldcode == -1)	/* EOF already? */
		return (0);	/* Get out of here */

	/* First code must be 8 bits = char. */
	*bp++ = (u_char)zs->zs_finchar;
	count--;
	zs->zs_stackp = de_stack;

	while ((zs->zs_code = getcode(zs)) > -1) {

		if ((zs->zs_code == CLEAR) && zs->zs_block_compress) {
			for (zs->zs_code = 255; zs->zs_code >= 0;
			    zs->zs_code--)
				tab_prefixof(zs->zs_code) = 0;
			zs->zs_clear_flg = 1;
			zs->zs_free_ent = FIRST - 1;
			if ((zs->zs_code = getcode(zs)) == -1)	/* O, untimely death! */
				break;
		}
		zs->zs_incode = zs->zs_code;

		/* Special case for KwKwK string. */
		if (zs->zs_code >= zs->zs_free_ent) {
			*zs->zs_stackp++ = zs->zs_finchar;
			zs->zs_code = zs->zs_oldcode;
		}

		/* Generate output characters in reverse order. */
		while (zs->zs_code >= 256) {
			/*
			 * Bad input file may cause zs_stackp to overflow
			 * zs_htab; check here and abort decompression,
			 * that's better than dumping core.
			 */
			if (zs->zs_stackp >= (u_char *)&zs->zs_htab[HSIZE]) {
				return (BUFFILEEOF);
			}
			*zs->zs_stackp++ = tab_suffixof(zs->zs_code);
			zs->zs_code = tab_prefixof(zs->zs_code);
		}
		*zs->zs_stackp++ = zs->zs_finchar = tab_suffixof(zs->zs_code);

		/* And put them out in forward order.  */
middle:		do {
			if (count-- == 0) {
				zs->zs_bytes_out += BUFFILESIZE;
				zsf->left = BUFFILESIZE - 1;
				zsf->bufp = zsf->buffer + 1;
				return (zsf->buffer[0]);
			}
			*bp++ = *--zs->zs_stackp;
		} while (zs->zs_stackp > de_stack);

		/* Generate the new entry. */
		if ((zs->zs_code = zs->zs_free_ent) < zs->zs_maxmaxcode) {
			tab_prefixof(zs->zs_code) = (u_short) zs->zs_oldcode;
			tab_suffixof(zs->zs_code) = zs->zs_finchar;
			zs->zs_free_ent = zs->zs_code + 1;
		}

		/* Remember previous code. */
		zs->zs_oldcode = zs->zs_incode;
	}
	zs->zs_state = S_EOF;
	zs->zs_bytes_out += BUFFILESIZE - count;
eof:
	if (BUFFILESIZE - count) {
		zsf->left = (BUFFILESIZE - count) - 1;
		zsf->bufp = zsf->buffer + 1;
		return (zsf->buffer[0]);
	}
	zsf->left = 0;
	return (BUFFILEEOF);
}

/*-
 * Read one code from the standard input.  If BUFFILEEOF, return -1.
 * Inputs:
 *	stdin
 * Outputs:
 *	code or -1 is returned.
 */
static code_int
getcode(struct s_zstate *zs)
{
	code_int gcode;
	int r_off, bits;
	u_char *bp;

	if (zs->zs_clear_flg > 0 || zs->zs_offset >= zs->zs_size ||
	    zs->zs_free_ent > zs->zs_maxcode) {

		zs->zs_bp += zs->zs_n_bits;
		/*
		 * If the next entry will be too big for the current gcode
		 * size, then we must increase the size.  This implies reading
		 * a new buffer full, too.
		 */
		if (zs->zs_free_ent > zs->zs_maxcode) {
			zs->zs_n_bits++;
			if (zs->zs_n_bits == zs->zs_maxbits) {
				/* Won't get any bigger now. */
				zs->zs_maxcode = zs->zs_maxmaxcode;
			} else
				zs->zs_maxcode = MAXCODE(zs->zs_n_bits);
		}
		if (zs->zs_clear_flg > 0) {
			zs->zs_maxcode = MAXCODE(zs->zs_n_bits = INIT_BITS);
			zs->zs_clear_flg = 0;
		}

		/* fill the buffer up to the neck */
		if (zs->zs_bp + zs->zs_n_bits > zs->zs_ebp) {
			for (bp = zs->zs_buf; zs->zs_bp < zs->zs_ebp;
				*bp++ = *zs->zs_bp++);
			bits = 0;
			while ((bits < (ZBUFSIZ - (bp - zs->zs_buf)))
			    && ((gcode = BufFileGet(zs->zs_file))
			    != BUFFILEEOF)) {
				*bp++ = gcode;
				++bits;
			}
			zs->zs_in_count += bits;
			zs->zs_bp = zs->zs_buf;
			zs->zs_ebp = bp;
		}
		zs->zs_offset = 0;
		zs->zs_size = MIN(zs->zs_n_bits, zs->zs_ebp - zs->zs_bp);
		if (zs->zs_size == 0)
			return (-1);
		/* Round size down to integral number of codes. */
		zs->zs_size = (zs->zs_size << 3) - (zs->zs_n_bits - 1);
	}

	bp = zs->zs_bp;
	r_off = zs->zs_offset;
	bits = zs->zs_n_bits;

	/* Get to the first byte. */
	bp += (r_off >> 3);
	r_off &= 7;

	/* Get first part (low order bits). */
	gcode = (*bp++ >> r_off);
	bits -= (8 - r_off);
	r_off = 8 - r_off;	/* Now, roffset into gcode word. */

	/* Get any 8 bit parts in the middle (<=1 for up to 16 bits). */
	if (bits >= 8) {
		gcode |= *bp++ << r_off;
		r_off += 8;
		bits -= 8;
	}

	/* High order bits. */
	gcode |= (*bp & rmask[bits]) << r_off;
	zs->zs_offset += zs->zs_n_bits;

	return (gcode);
}

BufFilePtr
BufFilePushCompressed(BufFilePtr f)
{
	struct s_zstate *zs;
	code_int gcode;

	if ((gcode = BufFileGet(f)) != z_magic[0])
		return (0);
	if ((gcode = BufFileGet(f)) != z_magic[1])
		return (0);
	if ((gcode = BufFileGet(f)) == BUFFILEEOF)
		return (0);

	if ((zs = xalloc(sizeof(struct s_zstate))) == NULL)
		return (NULL);
	memset(zs, '\0', sizeof(struct s_zstate));

	/* max # bits/code. */
	zs->zs_maxbits = gcode & BIT_MASK;
	if (zs->zs_maxbits > BITS || zs->zs_maxbits < 12)
		return (0);
	/* Should NEVER generate this code. */
	zs->zs_maxmaxcode = 1L << zs->zs_maxbits;
	zs->zs_hsize = HSIZE;		/* For dynamic table sizing. */
	zs->zs_free_ent = 0;		/* First unused entry. */
	zs->zs_block_compress = gcode & BLOCK_MASK;
	zs->zs_clear_flg = 0;
	zs->zs_ratio = 0;
	zs->zs_checkpoint = CHECK_GAP;
	zs->zs_in_count = 3;		/* Length of input. */
	zs->zs_out_count = 0;		/* # of codes output (for debugging).*/
	zs->zs_state = S_START;
	zs->zs_offset = 0;
	zs->zs_size = 0;
	zs->zs_bp = zs->zs_ebp = zs->zs_buf;
	zs->zs_file = f;

	return (BufFileCreate((char *)zs, zread, NULL, zskip, zclose));
}
@


1.5
log
@sync with _MirOS: src/usr.bin/compress/zopen.c,v 1.10; CVE-2011-2895
@
text
@d2 1
a2 1
/**	$MirOS: src/usr.bin/compress/zopen.c,v 1.10 2011/10/11 19:25:29 tg Exp $ */
d86 1
a86 1
__RCSID("$MirOS: src/usr.bin/compress/zopen.c,v 1.10 2011/10/11 19:25:29 tg Exp $");
d315 1
a315 2
				errno = EINVAL;
				return (-1);
@


1.4
log
@mirbsd.org, 66h.42h.de, bsdadvocacy.org, and whatnot
we changed that too often, try to clean up the mess
mostly outside the www/ module which is dead anyway.
@
text
@d2 3
a4 2
/**	$MirOS: src/usr.bin/compress/zopen.c,v 1.7 2006/06/15 19:13:07 tg Exp $ */
/*	$OpenBSD: zopen.c,v 1.16 2005/06/26 18:20:26 otto Exp $	*/
d8 1
a8 1
 * Copyright (c) 2005, 2006
d82 5
a86 2
static const char __sccsid[] = "@@(#)zopen.c	8.1 (Berkeley) 6/27/93";
static const char __rcsid[] = "$MirOS: X11/xc/lib/font/fontfile/decompress.c,v 1.3 2005/12/17 05:46:05 tg Exp $";
d119 2
a120 2
	count_int zs_htab [HSIZE];
	u_short zs_codetab [HSIZE];
d143 1
a143 1
		} w;			/* Write paramenters */
d309 9
d455 1
a455 1
	if ((zs = xalloc(sizeof (struct s_zstate))) == NULL)
d457 1
d461 1
a461 1
	if (zs->zs_maxbits > BITS)
@


1.3
log
@big fat licence update (I left some which are bsiegert@@'s alone though)
also, remove licence boilerplate from some .h files who don't deserve it
and remove and add some advertising clauses because I say so
@
text
@d2 2
a3 2
/**	$MirOS: X11/xc/lib/font/fontfile/decompress.c,v 1.2 2005/04/14 18:06:24 tg Exp $ */
/*	$OpenBSD: zopen.c,v 1.14 2003/08/03 01:26:46 deraadt Exp $	*/
d7 2
a8 21
 * Copyright (c) 2005
 *	Thorsten "mirabile" Glaser <tg@@MirBSD.org>
 *
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publicly perform, modify,
 * merge, distribute, sell, give away or sublicence, provided all co-
 * pyright notices above, these terms and the disclaimer are retained
 * in all redistributions or reproduced in accompanying documentation
 * or other materials provided with binary redistributions.
 *
 * Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
 * express, or implied, to the maximum extent permitted by applicable
 * law, without malicious intent or gross negligence; in no event may
 * licensor, an author or contributor be held liable for any indirect
 * or other damage, or direct damage except proven a consequence of a
 * direct error of said person and intended use of this work, loss or
 * other issues arising in any way out of its use, even if advised of
 * the possibility of such damage or existence of a nontrivial bug.
 */

/*-
d39 11
d82 1
a82 1
static const char __rcsid[] = "$MirOS: X11/xc/lib/font/fontfile/decompress.c,v 1.2 2005/04/14 18:06:24 tg Exp $";
d210 1
a210 1
		return 0;
d215 1
a215 1
		return 0;
d221 1
a221 1
	return 1;
d231 2
a232 2
			return BUFFILEEOF;
	return 0;
d251 1
a251 1
		return BUFFILEEOF;
d255 1
a255 1
		return BUFFILEEOF;
d316 1
a316 1
				return zsf->buffer[0];
d337 1
a337 1
		return zsf->buffer[0];
d340 1
a340 1
	return BUFFILEEOF;
d397 1
a397 1
			return -1;
d436 1
a436 1
		return 0;
d438 1
a438 1
		return 0;
d440 1
a440 1
		return 0;
d442 1
a442 1
	if ((zs = xalloc(sizeof(struct s_zstate))) == NULL)
d448 1
a448 1
		return 0;
d465 1
a465 1
	return BufFileCreate((char *)zs, zread, NULL, zskip, zclose);
@


1.2
log
@make libXfont (thus all Xlib""s - according to Branden Robinson for XF4.3)
compatible to the GPL by taking src/usr.bin/compress/zopen.c
and hacking on it for the Xlib interface.

Works for me with:
-rw-rw-r--  1 tg  tg  433147 Apr 14 17:58 foo.bdf.Z
@
text
@d2 1
a2 1
/**	$MirOS: src/usr.bin/compress/zopen.c,v 1.3 2005/04/14 11:46:45 tg Exp $ */
d17 8
a24 7
 * Licensor hereby provides this work "AS IS" and WITHOUT WARRANTY of
 * any kind, expressed or implied, to the maximum extent permitted by
 * applicable law, but with the warranty of being written without ma-
 * licious intent or gross negligence; in no event shall licensor, an
 * author or contributor be held liable for any damage, direct, indi-
 * rect or other, however caused, arising in any way out of the usage
 * of this work, even if advised of the possibility of such damage.
d90 1
a90 1
static const char __rcsid[] = "$MirOS: src/usr.bin/compress/zopen.c,v 1.3 2005/04/14 11:46:45 tg Exp $";
@


1.1
log
@Initial revision
@
text
@d1 28
a28 4
/* $Xorg: decompress.c,v 1.4 2001/02/09 02:04:03 xorgcvs Exp $ */
/*
 * Copyright 1985, 1986 The Regents of the University of California.
 * All rights reserved.
d31 30
a60 2
 * James A. Woods, derived from original work by Spencer Thomas
 * and Joseph Orost.
d62 17
a78 11
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d81 20
a100 1
/*
d102 2
a103 1
Copyright 1993, 1998  The Open Group
d105 3
a107 24
Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

*/
/* $XFree86: xc/lib/font/fontfile/decompress.c,v 1.5 2001/12/14 19:56:50 dawes Exp $ */
/* 
 * decompress - cat a compressed file
d109 3
d113 42
a154 2
#include "fontmisc.h"
#include <bufio.h>
d156 12
a167 1
#define BITS	16
d170 6
a175 1
 * a code_int must be able to hold 2**BITS values of type int, and also -1
a176 5
#if BITS > 15
typedef long int	code_int;
#else
typedef int		code_int;
#endif
d178 6
a183 1
typedef long int	  count_int;
d185 1
a185 22
#ifdef NO_UCHAR
 typedef char	char_type;
#else
 typedef	unsigned char	char_type;
#endif /* UCHAR */

static char_type magic_header[] = { "\037\235" };	/* 1F 9D */

/* Defines for third byte of header */
#define BIT_MASK	0x1f
#define BLOCK_MASK	0x80
/* Masks 0x40 and 0x20 are free.  I think 0x20 should mean that there is
   a fourth header byte (for expansion).
*/

#define INIT_BITS 9			/* initial number of bits/code */

#ifdef COMPATIBLE		/* But wrong! */
# define MAXCODE(n_bits)	(1 << (n_bits) - 1)
#else
# define MAXCODE(n_bits)	((1 << (n_bits)) - 1)
#endif /* COMPATIBLE */
d190 3
a192 38
 */ 
#define FIRST	257	/* first free entry */
#define	CLEAR	256	/* table clear output code */

#define STACK_SIZE  8192

typedef struct _compressedFILE {
    BufFilePtr	    file;

    char_type	    *stackp;
    code_int	    oldcode;
    char_type	    finchar;

    int		block_compress;
    int		maxbits;
    code_int	maxcode, maxmaxcode;

    code_int	free_ent;
    int		clear_flg;
    int		n_bits;

    /* bit buffer */
    int		offset, size;
    char_type	buf[BITS];

    char_type	    de_stack[STACK_SIZE];
    char_type	    *tab_suffix;
    unsigned short  *tab_prefix;
} CompressedFile;


static int hsize_table[] = {
    5003,	/* 12 bits - 80% occupancy */
    9001,	/* 13 bits - 91% occupancy */
    18013,	/* 14 bits - 91% occupancy */
    35023,	/* 15 bits - 94% occupancy */
    69001	/* 16 bits - 95% occupancy */
};
d194 15
a208 4
static int BufCompressedClose ( BufFilePtr f, int doClose );
static int BufCompressedFill ( BufFilePtr f );
static code_int getcode ( CompressedFile *file );
static int BufCompressedSkip ( BufFilePtr f, int bytes );
d210 2
a211 2
BufFilePtr
BufFilePushCompressed (BufFilePtr f)
d213 16
a228 51
    int		    code;
    int		    maxbits;
    int		    hsize;
    CompressedFile  *file;
    int		    extra;

    if ((BufFileGet(f) != (magic_header[0] & 0xFF)) ||
	(BufFileGet(f) != (magic_header[1] & 0xFF)))
    {
	return 0;
    }
    code = BufFileGet (f);
    if (code == BUFFILEEOF) return 0;
    
    maxbits = code & BIT_MASK;
    if (maxbits > BITS || maxbits < 12)
	return 0;
    hsize = hsize_table[maxbits - 12];
    extra = (1 << maxbits) * sizeof (char_type) +
	    hsize * sizeof (unsigned short);
    file = (CompressedFile *) xalloc (sizeof (CompressedFile) + extra);
    if (!file)
	return 0;
    file->file = f;
    file->maxbits = maxbits;
    file->block_compress = code & BLOCK_MASK;
    file->maxmaxcode = 1 << file->maxbits;
    file->tab_suffix = (char_type *) &file[1];
    file->tab_prefix = (unsigned short *) (file->tab_suffix + file->maxmaxcode);
    /*
     * As above, initialize the first 256 entries in the table.
     */
    file->maxcode = MAXCODE(file->n_bits = INIT_BITS);
    for ( code = 255; code >= 0; code-- ) {
	file->tab_prefix[code] = 0;
	file->tab_suffix[code] = (char_type) code;
    }
    file->free_ent = ((file->block_compress) ? FIRST : 256 );
    file->clear_flg = 0;
    file->offset = 0;
    file->size = 0;
    file->stackp = file->de_stack;
    bzero(file->buf, BITS);
    file->finchar = file->oldcode = getcode (file);
    if (file->oldcode != -1)
	*file->stackp++ = file->finchar;
    return BufFileCreate ((char *) file,
			  BufCompressedFill,
			  0,
			  BufCompressedSkip,
			  BufCompressedClose);
d232 1
a232 1
BufCompressedClose (BufFilePtr f, int doClose)
d234 1
a234 2
    CompressedFile  *file;
    BufFilePtr	    raw;
d236 4
a239 5
    file = (CompressedFile *) f->private;
    raw = file->file;
    xfree (file);
    BufFileClose (raw, doClose);
    return 1;
d242 8
d251 1
a251 1
BufCompressedFill (BufFilePtr f)
d253 94
a346 74
    CompressedFile  *file;
    register char_type *stackp, *de_stack;
    register char_type finchar;
    register code_int code, oldcode, incode;
    BufChar	    *buf, *bufend;

    file = (CompressedFile *) f->private;

    buf = f->buffer;
    bufend = buf + BUFFILESIZE;
    stackp = file->stackp;
    de_stack = file->de_stack;
    finchar = file->finchar;
    oldcode = file->oldcode;
    while (buf < bufend) {
	while (stackp > de_stack && buf < bufend)
	    *buf++ = *--stackp;

	if (buf == bufend)
	    break;

	if (oldcode == -1)
	    break;

	code = getcode (file);
	if (code == -1)
	    break;
    
    	if ( (code == CLEAR) && file->block_compress ) {
	    for ( code = 255; code >= 0; code-- )
	    	file->tab_prefix[code] = 0;
	    file->clear_flg = 1;
	    file->free_ent = FIRST - 1;
	    if ( (code = getcode (file)) == -1 )	/* O, untimely death! */
	    	break;
    	}
    	incode = code;
    	/*
     	 * Special case for KwKwK string.
     	 */
    	if ( code >= file->free_ent ) {
	    *stackp++ = finchar;
	    code = oldcode;
    	}
    
    	/*
     	 * Generate output characters in reverse order
     	 */
    	while ( code >= 256 )
    	{
	    *stackp++ = file->tab_suffix[code];
	    code = file->tab_prefix[code];
    	}
	finchar = file->tab_suffix[code];
	*stackp++ = finchar;
    
    	/*
     	 * Generate the new entry.
     	 */
    	if ( (code=file->free_ent) < file->maxmaxcode ) {
	    file->tab_prefix[code] = (unsigned short)oldcode;
	    file->tab_suffix[code] = finchar;
	    file->free_ent = code+1;
    	} 
	/*
	 * Remember previous code.
	 */
	oldcode = incode;
    }
    file->oldcode = oldcode;
    file->stackp = stackp;
    file->finchar = finchar;
    if (buf == f->buffer) {
	f->left = 0;
a347 4
    }
    f->bufp = f->buffer + 1;
    f->left = (buf - f->buffer) - 1;
    return f->buffer[0];
d350 1
a350 3
/*****************************************************************
 * TAG( getcode )
 *
d353 1
a353 1
 * 	stdin
d355 1
a355 1
 * 	code or -1 is returned.
a356 3

static char_type rmask[9] = {0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff};

d358 1
a358 1
getcode(CompressedFile *file)
d360 47
a406 19
    register code_int code;
    register int r_off, bits;
    register char_type *bp = file->buf;
    register BufFilePtr	raw;

    if ( file->clear_flg > 0 || file->offset >= file->size ||
	file->free_ent > file->maxcode )
    {
	/*
	 * If the next entry will be too big for the current code
	 * size, then we must increase the size.  This implies reading
	 * a new buffer full, too.
	 */
	if ( file->free_ent > file->maxcode ) {
	    file->n_bits++;
	    if ( file->n_bits == file->maxbits )
		file->maxcode = file->maxmaxcode;	/* won't get any bigger now */
	    else
		file->maxcode = MAXCODE(file->n_bits);
d408 19
a426 3
	if ( file->clear_flg > 0) {
    	    file->maxcode = MAXCODE (file->n_bits = INIT_BITS);
	    file->clear_flg = 0;
a427 43
	bits = file->n_bits;
	raw = file->file;
	while (bits > 0 && (code = BufFileGet (raw)) != BUFFILEEOF)
	{
	    *bp++ = code;
	    --bits;
	}
	bp = file->buf;
	if (bits == file->n_bits)
	    return -1;			/* end of file */
	file->size = file->n_bits - bits;
	file->offset = 0;
	/* Round size down to integral number of codes */
	file->size = (file->size << 3) - (file->n_bits - 1);
    }
    r_off = file->offset;
    bits = file->n_bits;
    /*
     * Get to the first byte.
     */
    bp += (r_off >> 3);
    r_off &= 7;
    /* Get first part (low order bits) */
#ifdef NO_UCHAR
    code = ((*bp++ >> r_off) & rmask[8 - r_off]) & 0xff;
#else
    code = (*bp++ >> r_off);
#endif /* NO_UCHAR */
    bits -= (8 - r_off);
    r_off = 8 - r_off;		/* now, offset into code word */
    /* Get any 8 bit parts in the middle (<=1 for up to 16 bits). */
    if ( bits >= 8 ) {
#ifdef NO_UCHAR
	code |= (*bp++ & 0xff) << r_off;
#else
	code |= *bp++ << r_off;
#endif /* NO_UCHAR */
	r_off += 8;
	bits -= 8;
    }
    /* high order bits. */
    code |= (*bp & rmask[bits]) << r_off;
    file->offset += file->n_bits;
d429 5
a433 1
    return code;
d436 2
a437 2
static int
BufCompressedSkip (BufFilePtr f, int bytes)
d439 32
a470 9
    int		    c;
    while (bytes--) 
    {
	c = BufFileGet(f);
	if (c == BUFFILEEOF)
	    return BUFFILEEOF;
    }
    return 0;
}
d472 1
a472 15
#ifdef TEST
int
main (int argc, char *argv[])
{
    BufFilePtr	    inputraw, input, output;
    int		    c;
    
    inputraw = BufFileOpenRead (0);
    input = BufFilePushCompressed (inputraw);
    output = BufFileOpenWrite (1);
    while ((c = BufFileGet (input)) != BUFFILEEOF)
	BufFilePut (c, output);
    BufFileClose (input, FALSE);
    BufFileClose (output, FALSE);
    return 0;
a473 1
#endif
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
